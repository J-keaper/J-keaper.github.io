<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32%C3%9732.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16%C3%9716.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第一章 理解网络编程和套接字1. 理解网络编程和套接字 网络编程就是编写程序使得两台计算机相互交换数据。 套接字是网络传输所用的软件设备。  2. 基于linux的文件操作 对于linux而言，socket操作和文件操作没有区别。socket也被认为是文件的一种，因此在网络数据传输过程中可以使用文件I&#x2F;O的相关函数。而Windows是区分socket与文件的。 文件描述符：系统分配给文件或套接字的">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP网络编程复习总结(1)">
<meta property="og:url" content="http://yoursite.com/2017/06/06/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(1)/index.html">
<meta property="og:site_name" content="Keaper&#39;s Blog">
<meta property="og:description" content="第一章 理解网络编程和套接字1. 理解网络编程和套接字 网络编程就是编写程序使得两台计算机相互交换数据。 套接字是网络传输所用的软件设备。  2. 基于linux的文件操作 对于linux而言，socket操作和文件操作没有区别。socket也被认为是文件的一种，因此在网络数据传输过程中可以使用文件I&#x2F;O的相关函数。而Windows是区分socket与文件的。 文件描述符：系统分配给文件或套接字的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-06-06T13:23:00.000Z">
<meta property="article:modified_time" content="2020-07-29T16:55:43.028Z">
<meta property="article:author" content="Keaper">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="http://yoursite.com/2017/06/06/tcpip复习总结(1)/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>TCP/IP网络编程复习总结(1) | Keaper's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keaper's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/06/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TCP/IP网络编程复习总结(1)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-06 13:23:00" itemprop="dateCreated datePublished" datetime="2017-06-06T13:23:00+00:00">2017-06-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-29 16:55:43" itemprop="dateModified" datetime="2020-07-29T16:55:43+00:00">2020-07-29</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章-理解网络编程和套接字"><a href="#第一章-理解网络编程和套接字" class="headerlink" title="第一章 理解网络编程和套接字"></a>第一章 理解网络编程和套接字</h1><h2 id="1-理解网络编程和套接字"><a href="#1-理解网络编程和套接字" class="headerlink" title="1. 理解网络编程和套接字"></a>1. 理解网络编程和套接字</h2><ul>
<li>网络编程就是编写程序使得两台计算机相互交换数据。</li>
<li>套接字是网络传输所用的软件设备。</li>
</ul>
<h2 id="2-基于linux的文件操作"><a href="#2-基于linux的文件操作" class="headerlink" title="2. 基于linux的文件操作"></a>2. 基于linux的文件操作</h2><ul>
<li>对于linux而言，socket操作和文件操作没有区别。socket也被认为是文件的一种，因此在网络数据传输过程中可以使用文件I/O的相关函数。而Windows是区分socket与文件的。</li>
<li>文件描述符：系统分配给文件或套接字的一个整数，用以标识文件或者套接字。    </li>
<li>标准输出输出以及标准错误文件描述符：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">文件描述符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准输入：stdin</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">标准输出：stdout</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">标准错误：stderr</td>
<td align="center">2</td>
</tr>
</tbody></table>
<h2 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3. 文件操作"></a>3. 文件操作</h2><p><strong>打开文件open()</strong></p>
<ul>
<li>头文件：<code>&lt;sys/types.h&gt;</code>,<code>&lt;sys/stat.h&gt;</code>, <code>&lt;fcntl.h&gt;</code><br><em>注：文件的打开模式定义在头文件<code>&lt;sys/stat.h&gt;</code>中，<code>&lt;sys/types.h&gt;</code>中定义了各种数据类型，open()函数定义在<code>&lt;fcntl.h&gt;</code>头文件中。</em></li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> str * path, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值：成功则返回文件描述符，出错返回-1 </li>
<li>参数：<ul>
<li>path: 打开或创建的文件的路径名 </li>
<li>flag：文件打开模式信息</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">打开模式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O_CREAT</td>
<td align="center">必要时创建文件</td>
</tr>
<tr>
<td align="center">O_TRUNC</td>
<td align="center">删除全部现有数据</td>
</tr>
<tr>
<td align="center">O_APPEND</td>
<td align="center">维持现有数据，白村到其后面</td>
</tr>
<tr>
<td align="center">O_RDONLY</td>
<td align="center">只读打开</td>
</tr>
<tr>
<td align="center">O_WRONLY</td>
<td align="center">只写打开</td>
</tr>
<tr>
<td align="center">O_RDWR</td>
<td align="center">读写打开</td>
</tr>
</tbody></table>
<p><strong>关闭文件close()</strong></p>
<ul>
<li>需要包含的头文件：<code>&lt;unistd.h&gt;</code></li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd:需要关闭文件的文件描述符</li>
</ul>
</li>
</ul>
<p><strong>读取文件中的数据read()</strong></p>
<ul>
<li>需要包含的头文件：<code>&lt;unistd.h&gt;</code></li>
<li>函数原型：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值：成功时返回实际读到的字节数；已读到文件尾返回0，出错的话返回-1。</li>
<li>参数：<ul>
<li>fd：要读取的文件的描述符<ul>
<li>buf：得到的数据在内存中的位置的首地址</li>
<li>nbytes：要接受数据的最大字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>向文件中写数据write()</strong></p>
<ul>
<li>需要包含的头文件：<code>&lt;unistd.h&gt;</code></li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>功能：向打开的文件写数据</li>
<li>返回值：写入成功返回实际写入的字节数，出错返回-1</li>
<li>参数：<ul>
<li>fd：要写入文件的文件描述符</li>
<li>buf：要写入文件的数据在内存中存放位置的首地址</li>
<li>nbytes：要传输数据的最大字节数</li>
</ul>
</li>
<li>样例代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buf[]=<span class="string">"Hello World!"</span>;</span><br><span class="line">	</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"data.txt"</span>,O_CREAT|O_WRONLY|O_TRUNC); 	<span class="comment">//打开文件</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File descriptor : %d \n"</span>,fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(fd,buf,<span class="keyword">sizeof</span>(buf));	<span class="comment">//写数据</span></span><br><span class="line">	<span class="built_in">close</span>(fd);					<span class="comment">//关闭文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">	</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"data.txt"</span>,O_RDONLY);		<span class="comment">//打开文件</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File descriptor: %d \n"</span> , fd);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));			<span class="comment">//读数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File data: %s\n"</span>,buf);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd);			<span class="comment">//关闭文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-套接字类型与协议设置"><a href="#第二章-套接字类型与协议设置" class="headerlink" title="第二章 套接字类型与协议设置"></a>第二章 套接字类型与协议设置</h1><h2 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1. 创建套接字socket()"></a>1. 创建套接字socket()</h2><ul>
<li>需要包含的头文件 &lt;sys/socket.h&gt;</li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值：成功：文件描述符；否则：-1。</li>
<li>参数：<ul>
<li>domain：套接字所使用的协议族</li>
<li>type：套接字数据传输类型</li>
<li>protocol：套接字所使用的协议</li>
</ul>
</li>
</ul>
<h2 id="2-参数domain-常用协议族"><a href="#2-参数domain-常用协议族" class="headerlink" title="2. 参数domain:常用协议族"></a>2. 参数domain:常用协议族</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">协议族</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PF_INET</td>
<td align="center">IPv4互联网协议族</td>
</tr>
<tr>
<td align="center">PF_INET6</td>
<td align="center">IPv46互联网协议族</td>
</tr>
<tr>
<td align="center">PF_LOCAL</td>
<td align="center">本地通信的UNIX协议族</td>
</tr>
</tbody></table>
<h2 id="3-参数type-套接字类型"><a href="#3-参数type-套接字类型" class="headerlink" title="3. 参数type:套接字类型"></a>3. 参数type:套接字类型</h2><ul>
<li><p>类型1：面向连接的套接字（SOCK_STREAM）<br><strong>可靠、按序传递的、基于字节的面向连接的套接字。</strong></p>
<ul>
<li>传输过程中数据不会消失：错误重传</li>
<li>按序传输数据：按发送顺序放入buffer</li>
<li>传输的数据不存在数据边界</li>
<li>面向连接的套接字只能与另外一个同样特性的套接字连接，一一对应</li>
</ul>
</li>
<li><p>类型2：面向消息的套接字（SOCK_DGRAM）<br><strong>不可靠的、不按序传递、以数据的高速传输为目的的套接字。</strong></p>
<ul>
<li>快速传输而非传输顺序</li>
<li>传输的数据可能丢失也可能损毁</li>
<li>传输的数据有边界</li>
<li>每次传输的数据大小有限</li>
</ul>
</li>
</ul>
<h2 id="4-参数protocol-协议类型"><a href="#4-参数protocol-协议类型" class="headerlink" title="4. 参数protocol:协议类型"></a>4. 参数protocol:协议类型</h2><ul>
<li><p>如果一个协议族中存在多种数据传输方式，该参数用以确定最终采用的协议。如果前两个参数已唯一确定，这个参数传0即可。</p>
</li>
<li><p>创建TCP套接字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_STREAM,IPPROTO_TCP);</span><br></pre></td></tr></table></figure></li>
<li><p>创建UDP套接字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_DGRAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_DGRAM,IPPROTO_UDP);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第三章-地址族与数据序列"><a href="#第三章-地址族与数据序列" class="headerlink" title="第三章 地址族与数据序列"></a>第三章 地址族与数据序列</h1><h2 id="1-IP地址与端口号"><a href="#1-IP地址与端口号" class="headerlink" title="1. IP地址与端口号"></a>1. IP地址与端口号</h2><ul>
<li>IPv4的地址有4字节，32位。</li>
<li>端口号有16位构成，范围为0～65535。</li>
<li>端口号就是为了在同一个操作系统内区分不同套接字而设置的，无法将一个端口号分配给不同的套接字。</li>
</ul>
<h2 id="2-地址信息的表示"><a href="#2-地址信息的表示" class="headerlink" title="2. 地址信息的表示"></a>2. 地址信息的表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin_family;</span><br><span class="line">	<span class="keyword">uint16_t</span>        sin_port;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span>            sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-成员sin-family"><a href="#1-成员sin-family" class="headerlink" title="(1) 成员sin_family"></a>(1) 成员sin_family</h3><p>地址族，每种协议族适用的地址族均不同。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">地址族</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AF_INET</td>
<td align="center">IPv4网络协议使用的地址族</td>
</tr>
<tr>
<td align="center">AF_INET6</td>
<td align="center">IPv6网络协议使用的地址族</td>
</tr>
<tr>
<td align="center">AF_LOCAL</td>
<td align="center">本地通信中采用的UNIX协议的地址族</td>
</tr>
</tbody></table>
<h3 id="2-成员sin-port"><a href="#2-成员sin-port" class="headerlink" title="(2) 成员sin_port"></a>(2) 成员sin_port</h3><p>16位端口号，以网络字节序保存。</p>
<h3 id="3-成员sin-addr"><a href="#3-成员sin-addr" class="headerlink" title="(3) 成员sin_addr"></a>(3) 成员sin_addr</h3><p>保存32位地址信息，以网络字节序保存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-成员sin-zero"><a href="#4-成员sin-zero" class="headerlink" title="(4) 成员sin_zero"></a>(4) 成员sin_zero</h3><p>无特殊含义，是为了使sockaddr_in的大小与sockaddr结构体的大小一致而插入的，必须填充为0.</p>
<h2 id="3-sockaddr-in结构体的使用"><a href="#3-sockaddr-in结构体的使用" class="headerlink" title="3. sockaddr_in结构体的使用"></a>3. sockaddr_in结构体的使用</h2><p>bind函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure>
<p>第二个参数接期望得到一个sockaddr结构体变量地址值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span>     sin_family; </span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];				<span class="comment">/* Address data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以使用时要将sockaddr_in结构体变量的地址转换位sockaddr结构体变量的指针，然后再传递给bind函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">…………</span><br><span class="line"><span class="keyword">if</span>(bind(serv_sock, (struct sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>); </span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<h2 id="4-网络字节序与地址变换"><a href="#4-网络字节序与地址变换" class="headerlink" title="4. 网络字节序与地址变换"></a>4. 网络字节序与地址变换</h2><ul>
<li>字节序有大端小端之分。<ul>
<li>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。</li>
<li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。</li>
</ul>
</li>
<li>网络字节序统一为大端方式。所以传输之前应该进行字节序转换。</li>
<li>为了进行转换socket提供了转换的函数有下面四个:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;			\\头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> short)</span></span>; 	\\把<span class="keyword">unsigned</span> short类型从主机序转换到网络序</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> short)</span></span>; 	\\把<span class="keyword">unsigned</span> short类型从网络序转换到主机序</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>; 	\\把<span class="keyword">unsigned</span> <span class="keyword">long</span>类型从主机序转换到网络序</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;	\\把<span class="keyword">unsigned</span> <span class="keyword">long</span>类型从网络序转换到主机序</span><br></pre></td></tr></table></figure></li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> short host_port=<span class="number">0x1234</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> short net_port;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> host_addr=<span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> net_addr;</span><br><span class="line">	</span><br><span class="line">	net_port = htons(host_port);</span><br><span class="line">	net_addr = htons(host_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Host ordered port: %#x \n"</span>, host_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Network ordered port: %#x \n"</span>, net_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Host ordered address: %#lx \n"</span>, host_addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Network ordered address: %#lx \n"</span>, net_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Host ordered port: 0x1234 </span></span><br><span class="line"><span class="comment">Network ordered port: 0x3412 </span></span><br><span class="line"><span class="comment">Host ordered address: 0x12345678 </span></span><br><span class="line"><span class="comment">Network ordered address: 0x7856</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="5-网络地址的初始化与分配"><a href="#5-网络地址的初始化与分配" class="headerlink" title="5. 网络地址的初始化与分配"></a>5. 网络地址的初始化与分配</h2><h3 id="1-将字符串信息转换为网络字节序的整数型值"><a href="#1-将字符串信息转换为网络字节序的整数型值" class="headerlink" title="(1) 将字符串信息转换为网络字节序的整数型值"></a>(1) 将字符串信息转换为网络字节序的整数型值</h3><p><strong>inet_addr()函数</strong></p>
<ul>
<li>头文件：&lt;arpa/inet.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：点分十进制格式的IP地址字符串</li>
<li>返回值： 成功返回32位大端序整数型值，失败返回INADDR_NONE。</li>
</ul>
<p><strong>inet_aton()函数</strong></p>
<ul>
<li>头文件：&lt;arpa/inet.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>, struct in_addr *addr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>string—点分十进制格式的IP地址字符串</li>
<li>addr—保存转换结果的in_addr结构体变量的地址值。</li>
</ul>
</li>
<li>返回值：成功返回1，失败返回0</li>
</ul>
<p><strong>inet_ntoa()函数</strong> </p>
<ul>
<li>头文件：&lt;arpa/inet.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span> <span class="params">(struct in_addr adr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：需要转换的in_addr结构体</li>
<li>返回值：成功时返回转换的字符串地址值，失败返回-1</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *addr1=<span class="string">"1.2.3.4"</span>;</span><br><span class="line">	<span class="keyword">char</span> *addr2=<span class="string">"127.212.124.256"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> conv_addr = inet_addr(addr1);</span><br><span class="line">	<span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error occured! \n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n"</span>, conv_addr);</span><br><span class="line">	</span><br><span class="line">	conv_addr = inet_addr(addr2);</span><br><span class="line">	<span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error occureded \n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n\n"</span>, conv_addr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Network ordered integer addr: 0x4030201 </span></span><br><span class="line"><span class="comment">Error occureded</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * addr = <span class="string">"1.2.3.4"</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!inet_aton(addr,&amp;addr_inet.sin_addr))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Conversion error"</span>);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#x \n"</span>,addr_inet.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Network ordered integer addr: 0x4030201</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> * str_ptr;</span><br><span class="line">	addr.sin_addr.s_addr = htonl(<span class="number">0x1020304</span>);</span><br><span class="line">	str_ptr= inet_ntoa(addr.sin_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dotted-Decimal notation: %s \n"</span>,str_ptr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Dotted-Decimal notation: 1.2.3.4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-常见的套接字创建过程中网络地址信息初始化方法"><a href="#2-常见的套接字创建过程中网络地址信息初始化方法" class="headerlink" title="(2) 常见的套接字创建过程中网络地址信息初始化方法"></a>(2) 常见的套接字创建过程中网络地址信息初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in addr;</span><br><span class="line">char * serv_ip &#x3D;&quot;211.217.168.13&quot;;</span><br><span class="line">char * serv_port &#x3D; &quot;9190&quot;;</span><br><span class="line">memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">addr.sin_family&#x3D;AF_INET;</span><br><span class="line">addr.sin_addr.s_addr&#x3D;htonl(serv_ip);</span><br><span class="line">addr.sin_port&#x3D;htons(atoi(serv_port));</span><br></pre></td></tr></table></figure>
<p>可以利用INADDR_ANY常量分配服务端IP地址，自动获取本机IP。</p>
<h3 id="3-向套接字分配网络地址-bind-函数"><a href="#3-向套接字分配网络地址-bind-函数" class="headerlink" title="(3) 向套接字分配网络地址 bind()函数"></a>(3) 向套接字分配网络地址 bind()函数</h3><ul>
<li>功能：<br>  bind函数将socket与网络地址信息绑定。</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sockfd—要分配地址信息的套接字文件描述符</li>
<li>myaddr—存有地址信息的sockaddr结构体变量的地址值。</li>
<li>addrlen—第二个结构体变量的长度</li>
</ul>
</li>
<li>返回值：<br>  成功返回0，失败返回-1</li>
</ul>
<h1 id="第四、五章-基于TCP的服务端-客户端"><a href="#第四、五章-基于TCP的服务端-客户端" class="headerlink" title="第四、五章 基于TCP的服务端/客户端"></a>第四、五章 基于TCP的服务端/客户端</h1><h2 id="1-TCP服务器端的默认函数调用顺序"><a href="#1-TCP服务器端的默认函数调用顺序" class="headerlink" title="1. TCP服务器端的默认函数调用顺序"></a>1. TCP服务器端的默认函数调用顺序</h2><ul>
<li>socket() 创建套接字</li>
<li>bind() 分配给套接字地址</li>
<li>listen() 等待连接请求状态</li>
<li>accept() 允许连接，接收新连接</li>
<li>read()/write() 数据交换</li>
<li>close() 关闭套接字，断开连接</li>
</ul>
<h2 id="2-进入等待连接请求状态-listen-函数"><a href="#2-进入等待连接请求状态-listen-函数" class="headerlink" title="2. 进入等待连接请求状态 listen()函数"></a>2. 进入等待连接请求状态 listen()函数</h2><ul>
<li>功能：<br>  进入等待连接请求状态</li>
<li>原型：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(int sock, int backlog);</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—希望进入等待连接请求状态的套接字文件描述符，该套接字将变为服务端套接字即监听套接字。</li>
<li>backlog—连接请求等待队列的长度。</li>
</ul>
</li>
<li>返回值：<br>  成功返回0，失败返回-1</li>
</ul>
<h2 id="3-受理客户端连接请求-connect-函数"><a href="#3-受理客户端连接请求-connect-函数" class="headerlink" title="3. 受理客户端连接请求 connect()函数"></a>3. 受理客户端连接请求 connect()函数</h2><ul>
<li>功能：接受客户端连接请求</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sock, struct sockaddr * addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—服务端套接字文件描述符</li>
<li>addr—保存发起连接请求的客户端地址信息的变量地址值，函数调用完成后，该地址保存的是客户端地址信息</li>
<li>addrlen—保存第二个参数sockaddr结构体的长度，函数调用完成后，该地址保存的客户端地址信息的长度</li>
</ul>
</li>
<li>返回值：成功时返回创建的套接字文件描述符，用以数据交换，失败时返回-1</li>
</ul>
<h2 id="4-TCP客户端的默认函数调用顺序"><a href="#4-TCP客户端的默认函数调用顺序" class="headerlink" title="4. TCP客户端的默认函数调用顺序"></a>4. TCP客户端的默认函数调用顺序</h2><ul>
<li>socket() 创建套接字</li>
<li>connect() 请求连接</li>
<li>read()/write() 数据交换</li>
<li>close() 关闭套接字，断开连接</li>
</ul>
<h2 id="5-客户端发起连接请求connect-函数"><a href="#5-客户端发起连接请求connect-函数" class="headerlink" title="5. 客户端发起连接请求connect()函数"></a>5. 客户端发起连接请求connect()函数</h2><ul>
<li><p>功能：<br>  请求连接到服务器</p>
</li>
<li><p>原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sock, struct sockaddr * servaddr, socklen_t addrlen);</span><br></pre></td></tr></table></figure></li>
<li><p>参数：</p>
<ul>
<li>sock—客户端套接字文件描述符</li>
<li>servaddr—存有目标服务器端地址信息的变量地址值</li>
<li>addrlen—第二个参数sockaddr结构体的长度</li>
</ul>
</li>
<li><p>客户端调用connect函数后，发生一下情况之一才会返回：</p>
</li>
</ul>
<ol>
<li>服务端接受连接请求。</li>
<li>发生断网等异常情况而中断连接请求。</li>
</ol>
<ul>
<li>注：客户端的IP地址和端口号在调用connect函数是自动分配。</li>
</ul>
<h2 id="6-第一个基于TCP的服务端-客户端—HelloWorld服务器"><a href="#6-第一个基于TCP的服务端-客户端—HelloWorld服务器" class="headerlink" title="6. 第一个基于TCP的服务端/客户端—HelloWorld服务器"></a>6. 第一个基于TCP的服务端/客户端—HelloWorld服务器</h2><p>服务端代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义套接字</span></span><br><span class="line">	<span class="keyword">int</span> serv_sock; <span class="comment">//用于监听的套接字</span></span><br><span class="line">	<span class="keyword">int</span> clnt_sock; <span class="comment">//用于数据传输的套接字</span></span><br><span class="line">	<span class="comment">//定义地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">//服务端地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span> <span class="comment">//请求连接的客户端地址信息</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clnt_addr_size;	<span class="comment">//客户端地址信息长度</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> message[]=<span class="string">"Hello World!"</span>;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	serv_sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//地址信息初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family = AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">//绑定地址信息</span></span><br><span class="line">		<span class="comment">//需要将sockaddr_in结构体变量地址强制转换为sockaddr结构体类型指针</span></span><br><span class="line">	<span class="keyword">if</span>(bind(serv_sock,(struct sockaddr*) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>) </span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"liste() error"</span>);</span><br><span class="line">	<span class="comment">//接受客户端连接请求</span></span><br><span class="line">		<span class="comment">//需要将sockaddr_in结构体变量地址强制转换为sockaddr结构体类型指针</span></span><br><span class="line">	clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">	clnt_sock = accept(serv_sock,(struct sockaddr*) &amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">	<span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">	<span class="comment">//向客户端发送一句“Hello World!”</span></span><br><span class="line">	<span class="built_in">write</span>(clnt_sock,message,<span class="keyword">sizeof</span>(message));</span><br><span class="line">	<span class="comment">//关闭数据交换套接字</span></span><br><span class="line">	<span class="built_in">close</span>(clnt_sock);</span><br><span class="line">	<span class="comment">//关闭监听套接字</span></span><br><span class="line">	<span class="built_in">close</span>(serv_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义套接字</span></span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="comment">//定义服务端地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	<span class="comment">//存放接受的消息</span></span><br><span class="line">	<span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//服务端地址信息初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family = AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">	<span class="comment">//请求连接服务端</span></span><br><span class="line">		<span class="comment">//需要将sockaddr_in结构体变量地址强制转换为sockaddr结构体类型指针</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">connect</span>(sock,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"conect() error!"</span>);</span><br><span class="line">	<span class="comment">//接受服务端发送的信息</span></span><br><span class="line">	<span class="keyword">int</span> str_len = <span class="built_in">read</span>(sock,message,<span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(str_len == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"read() error!"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>,message);</span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-基于TCP的服务端客户端函数调用关系"><a href="#7-基于TCP的服务端客户端函数调用关系" class="headerlink" title="7. 基于TCP的服务端客户端函数调用关系"></a>7. 基于TCP的服务端客户端函数调用关系</h2><p>服务端创建套接字后连续调用bind(),listen()函数进入等待状态，客户端创建套接字后通过connect()发起连接请求。服务端调用accept(),接受一个连接请求，接受之后客户端connect函数返回，双方进入数据交换阶段，如果队列中没有连接请求，则进入阻塞状态。数据交换阶段，通过调用read()/write()函数交换数据。结束之后调用close()关闭套接字，断开连接。</p>
<h2 id="8-迭代服务端-客户端"><a href="#8-迭代服务端-客户端" class="headerlink" title="8. 迭代服务端/客户端"></a>8. 迭代服务端/客户端</h2><h3 id="1-迭代服务端函数调用顺序"><a href="#1-迭代服务端函数调用顺序" class="headerlink" title="(1) 迭代服务端函数调用顺序"></a>(1) 迭代服务端函数调用顺序</h3><p>重复调用accept函数以实现可以向多个客户端提供服务但是统一时刻还是只能为一个客户端提供服务，与一个客户端通信是其他客户端只能阻塞。</p>
<h3 id="2-迭代的回声服务端-客户端"><a href="#2-迭代的回声服务端-客户端" class="headerlink" title="(2) 迭代的回声服务端/客户端"></a>(2) 迭代的回声服务端/客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">…………</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		clnt_sock=accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">		<span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">			error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Connected client %d \n"</span>, i+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>((str_len=<span class="built_in">read</span>(clnt_sock, message, BUF_SIZE))!=<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">write</span>(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">close</span>(clnt_sock);</span><br><span class="line">	&#125;</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>
<h2 id="9-解决TCP不存在数据边界的问题"><a href="#9-解决TCP不存在数据边界的问题" class="headerlink" title="9. 解决TCP不存在数据边界的问题"></a>9. 解决TCP不存在数据边界的问题</h2><p>自定义应用层协议</p>
<h2 id="10-TCP原理"><a href="#10-TCP原理" class="headerlink" title="10. TCP原理"></a>10. TCP原理</h2><h3 id="1-I-O缓冲"><a href="#1-I-O缓冲" class="headerlink" title="(1) I/O缓冲"></a>(1) I/O缓冲</h3><ul>
<li>I/O缓冲在每个TCP套接字中单独存在</li>
<li>I/O缓冲在创建套接字时自动生成</li>
<li>即使关闭套接字也会继续传递输出缓冲中遗留的数据</li>
<li>关闭套接字将丢失输入缓冲中的数据</li>
</ul>
<h3 id="2-套接字的连接"><a href="#2-套接字的连接" class="headerlink" title="(2) 套接字的连接"></a>(2) 套接字的连接</h3><p>三次握手</p>
<p><strong>套接字是以全双工的方式工作的，也就是说，它可以双向传递数据。</strong></p>
<h3 id="3-数据交换"><a href="#3-数据交换" class="headerlink" title="(3) 数据交换"></a>(3) 数据交换</h3><h3 id="4-断开套接字连接"><a href="#4-断开套接字连接" class="headerlink" title="(4) 断开套接字连接"></a>(4) 断开套接字连接</h3><p>四次挥手</p>
<h1 id="第六章-基于UDP的服务端-客户端"><a href="#第六章-基于UDP的服务端-客户端" class="headerlink" title="第六章 基于UDP的服务端/客户端"></a>第六章 基于UDP的服务端/客户端</h1><h2 id="1-UDP协议"><a href="#1-UDP协议" class="headerlink" title="1. UDP协议"></a>1. UDP协议</h2><ul>
<li>TCP比UDP慢的原因<ul>
<li>收发数据前后需要进行连接和清除过程</li>
<li>收发数据过程中需要添加流控制, 以保证数据可靠性</li>
</ul>
</li>
<li>UDP的高效使用<ul>
<li>如果数据完整性要求高, 使用TCP, 例如传送压缩的数据</li>
<li>如果可以容忍少量数据丢失, 使用UDP, 例如视频音频</li>
</ul>
</li>
</ul>
<h2 id="2-实现基于UDP的服务端-客户端"><a href="#2-实现基于UDP的服务端-客户端" class="headerlink" title="2. 实现基于UDP的服务端/客户端"></a>2. 实现基于UDP的服务端/客户端</h2><ul>
<li>UDP服务端和客户端没有连接<ul>
<li>不是面向连接的, 不需要连接过程</li>
<li>只需创建套接字, 然后进行数据交换, 不需要listen和accept</li>
</ul>
</li>
<li>UDP服务端和客户端均只需一个套接字<ul>
<li>TCP: 用于连接的套接字,以及数据交换的套接字(将保持连接)</li>
<li>UDP: 只需一个套接字(每次交换数据是需要添加目标地址信息)</li>
</ul>
</li>
</ul>
<h2 id="3-基于UDP的数据I-O函数"><a href="#3-基于UDP的数据I-O函数" class="headerlink" title="3. 基于UDP的数据I/O函数"></a>3. 基于UDP的数据I/O函数</h2><p><strong>sendto函数</strong></p>
<ul>
<li>功能：<br>  发送数据到对端</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> flags, struct sockaddr *to,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—用于传输数据的套接字文件描述符</li>
<li>buff—存有待传送数据的缓冲地址值</li>
<li>nbytes—待传输数据长度</li>
<li>flags—可选参数，若没有传递0</li>
<li>to—存有目标地址信息的sockaddr结构体变量的地址值</li>
<li>addrlen—参数to的地址值结构体变量长度</li>
</ul>
</li>
</ul>
<p><strong>recvfrom函数</strong></p>
<ul>
<li>功能：<br>  接收对端数据</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> flags, struct sockaddr * from,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—用于接受数据的套接字文件描述符</li>
<li>buff—用于保存接收数据的缓冲地址值</li>
<li>nbytes—可接收的最大字节数</li>
<li>flags—可选参数</li>
<li>from—存有发送端地址信息的sockaddr结构体变量的地址值</li>
<li>addrlen—参数法from的地址值结构体变量长度</li>
</ul>
</li>
</ul>
<p><strong>基于UDP的回声服务端/客户端:</strong></p>
<p>服务端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> serv_sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	serv_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"UDP socket() error"</span>);</span><br><span class="line">	<span class="comment">//初始化地址信息</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">//绑定地址信息</span></span><br><span class="line">	<span class="keyword">if</span>(bind(serv_sock,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	<span class="comment">//读写数据</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">		<span class="keyword">int</span> str_len = recvfrom(serv_sock,message,<span class="keyword">sizeof</span>(message),</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">		sendto(serv_sock,message,str_len,</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;clnt_addr,clnt_addr_size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(serv_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> addr_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	sock = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//初始化服务器地址信息</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">	<span class="comment">//数据交换</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"Insert message(q to quit): "</span>,<span class="built_in">stdout</span>);</span><br><span class="line">		fgets(message, <span class="keyword">sizeof</span>(message),<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		sendto(sock,message,<span class="built_in">strlen</span>(message),</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">		addr_size = <span class="keyword">sizeof</span>(serv_addr);</span><br><span class="line">		<span class="keyword">int</span> str_len = recvfrom(sock,message,BUF_SIZE,</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;serv_addr,&amp;addr_size);</span><br><span class="line">		message[str_len] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Message from server:  %s"</span>,message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：UDP客户端套接字的地址分配：调用sendto函数时自动分配IP和端口号。</strong></p>
<h2 id="4-UDP的数据传输特性"><a href="#4-UDP的数据传输特性" class="headerlink" title="4. UDP的数据传输特性"></a>4. UDP的数据传输特性</h2><p>UDP具有数据边界，传输过程中调用I/O函数的次数必须完全一致。<br>因为存在数据边界, 一个数据报即可成为一个完整数据,所以UDP套接字传输的数据包又称为数据报。</p>
<h2 id="5-未连接UDP套接字与已连接UDP套接字"><a href="#5-未连接UDP套接字与已连接UDP套接字" class="headerlink" title="5. 未连接UDP套接字与已连接UDP套接字"></a>5. 未连接UDP套接字与已连接UDP套接字</h2><ul>
<li>UDP套接字默认都是未连接套接字,每次sendto都要经历三个阶段：<ul>
<li>向UDP套接字注册目标IP和端口号</li>
<li>交换数据</li>
<li>删除UDP套接字中注册的目标地址信息</li>
</ul>
</li>
<li>如果连续想同一个IP地址和端口发送数据，未连接套接字浪费</li>
<li>已连接UDP套接字<br>创建已连接UDP套接字只需要针对套接字调用connect函数即可。之后可以使用sendto，recvfrom函数进行数据交换，还可以使用write，read函数交换数据。</li>
<li>示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sock,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">"Insert message(q to quit): "</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	fgets(message, <span class="keyword">sizeof</span>(message),<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	sendto(sock,message,strlen(message),</span></span><br><span class="line"><span class="comment">			0,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr));</span></span><br><span class="line"><span class="comment">	addr_size = sizeof(serv_addr);</span></span><br><span class="line"><span class="comment">	int str_len = recvfrom(sock,message,BUF_SIZE,</span></span><br><span class="line"><span class="comment">			0,(struct sockaddr *) &amp;serv_addr,&amp;addr_size);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(sock,message,<span class="built_in">strlen</span>(message));</span><br><span class="line">	<span class="keyword">int</span> str_len=<span class="built_in">read</span>(sock,message,BUF_SIZE);</span><br><span class="line"></span><br><span class="line">	message[str_len] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message from server:  %s"</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第七章-优雅地断开套接字连接"><a href="#第七章-优雅地断开套接字连接" class="headerlink" title="第七章 优雅地断开套接字连接"></a>第七章 优雅地断开套接字连接</h1><h2 id="1-基于TCP的半关闭"><a href="#1-基于TCP的半关闭" class="headerlink" title="1. 基于TCP的半关闭"></a>1. 基于TCP的半关闭</h2>半关闭：只关闭一部分数据交换中使用的流，即只关闭一个方向的数据交换。<h2 id="2-针对半关闭的shutdown-函数"><a href="#2-针对半关闭的shutdown-函数" class="headerlink" title="2. 针对半关闭的shutdown()函数"></a>2. 针对半关闭的shutdown()函数</h2></li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock — 要断开的套接字文件描述符</li>
<li>howto — 断开方式</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">howto值</th>
<th align="center">断开方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHUT_RD</td>
<td align="center">断开输入流</td>
</tr>
<tr>
<td align="center">SHUT_WR</td>
<td align="center">断开输出流</td>
</tr>
<tr>
<td align="center">SHUT_RDWR</td>
<td align="center">同时断开I/O流</td>
</tr>
</tbody></table>
<ul>
<li>返回值：成功返回0,失败返回-1</li>
</ul>
<h1 id="第八章-域名及网络地址"><a href="#第八章-域名及网络地址" class="headerlink" title="第八章 域名及网络地址"></a>第八章 域名及网络地址</h1><h2 id="1-域名系统"><a href="#1-域名系统" class="headerlink" title="1. 域名系统"></a>1. 域名系统</h2><ul>
<li>DNS是对IP地址和域名进行转换的系统，其核心是DNS服务器。</li>
</ul>
<h2 id="2-利用域名获取IP地址"><a href="#2-利用域名获取IP地址" class="headerlink" title="2. 利用域名获取IP地址"></a>2. 利用域名获取IP地址</h2><p><strong>gethostbyname函数</strong></p>
<ul>
<li>包含头文件：&lt;netdb.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<br>  hotname — 域名字符串</li>
<li>返回值：<br>  成功时返回hostent结构体地址，失败时返回NULL指针</li>
</ul>
<p><strong>hostent结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *h_name;			<span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="keyword">char</span> **h_aliases;		<span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="keyword">int</span> h_addrtype;		<span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="keyword">int</span> h_length;			<span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="keyword">char</span> **h_addr_list;		<span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>h_name：官方域名</li>
<li>h_aliases：多个域名列表</li>
<li>h_addrtype：地址类型，若是IPv4，则词变量为AF_INET</li>
<li>h_length：IP地址长度。若是IPv4，为4,若是IPv6，为16</li>
<li>h_addr_list：以整数形式保存的域名对应的IP地址</li>
</ul>
<h2 id="3-利用IP地址获取域名"><a href="#3-利用IP地址获取域名" class="headerlink" title="3. 利用IP地址获取域名"></a>3. 利用IP地址获取域名</h2><p><strong>gethostbyaddr函数</strong></p>
<ul>
<li>包含头文件：&lt;netdb.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>addr — 含有IP地址信息的in_addr结构体指针。为了同时传递IPv4地址之外的信息，该变量的类型声明为char型指针。</li>
<li>len — 第一个参数地址信息的字节数，IPv4为4,IPv6为16</li>
<li>family — 地址族信息，IPv4时为AF_INET，IPv6时为AF_INET6</li>
</ul>
</li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> * <span class="title">host</span>;</span></span><br><span class="line">	host = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Official name: %s \n"</span>, host-&gt;h_name);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_aliases[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Aliases %d: %s \n"</span>, i+<span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Address type: %s \n"</span>,</span><br><span class="line">			(host-&gt;h_addrtype==AF_INET)?<span class="string">"AF_INET"</span>:<span class="string">"AF_INET6"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_addr_list[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"IP addr %d : %s \n"</span>,i+<span class="number">1</span>,</span><br><span class="line">				inet_ntoa(*(struct in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">$./gethostbyname baidu.com</span></span><br><span class="line"><span class="comment">Official name: baidu.com </span></span><br><span class="line"><span class="comment">Address type: AF_INET </span></span><br><span class="line"><span class="comment">IP addr 1 : 180.149.132.47 </span></span><br><span class="line"><span class="comment">IP addr 2 : 220.181.57.217 </span></span><br><span class="line"><span class="comment">IP addr 3 : 111.13.101.208 </span></span><br><span class="line"><span class="comment">IP addr 4 : 123.125.114.144 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> * <span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	host = gethostbyaddr((<span class="keyword">char</span>*)&amp;addr.sin_addr,<span class="number">4</span>,AF_INET);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Official name: %s \n"</span>, host-&gt;h_name);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_aliases[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Aliases %d: %s \n"</span>, i+<span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Address type: %s \n"</span>,</span><br><span class="line">			(host-&gt;h_addrtype==AF_INET)?<span class="string">"AF_INET"</span>:<span class="string">"AF_INET6"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_addr_list[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"IP addr %d : %s \n"</span>,i+<span class="number">1</span>,</span><br><span class="line">				inet_ntoa(*(struct in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">$ ./gethostbyaddr 127.0.0.1</span></span><br><span class="line"><span class="comment">Official name: localhost </span></span><br><span class="line"><span class="comment">Address type: AF_INET </span></span><br><span class="line"><span class="comment">IP addr 1 : 127.0.0.1 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="第九章-套接字的多种选项"><a href="#第九章-套接字的多种选项" class="headerlink" title="第九章 套接字的多种选项"></a>第九章 套接字的多种选项</h1><h2 id="1-套接字选项"><a href="#1-套接字选项" class="headerlink" title="1. 套接字选项"></a>1. 套接字选项</h2><p><strong>getsockopt()</strong></p>
<ul>
<li>头文件 <code>&lt;sys/socket.h&gt;</code></li>
<li>功能：获取套接字选项</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock — 用于查看套接字选项的套接字文件描述符</li>
<li>level — 要查看选项的协议层</li>
<li>optname — 要查看的选项名</li>
<li>optval — 保存结果的缓冲地址值</li>
<li>optlen — 保存通过第四个参数返回的可选项信息的字节数</li>
</ul>
</li>
<li>返回值<br>  成功返回0,失败返回-1</li>
</ul>
<p><strong>setsockopt()</strong></p>
<ul>
<li>头文件 <code>&lt;sys/socket.h&gt;</code></li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock — 要设置可选项的套接字文件描述符</li>
<li>level — 要设置的选项的协议层</li>
<li>optname — 要设置的选项名</li>
<li>optval — 存有要设置的选项信息的缓冲地址值</li>
<li>optlen — 向参数optval传递的选项信息的字节数</li>
</ul>
</li>
<li>返回值：<br>  成功返回0,失败返回-1</li>
</ul>
<h2 id="2-I-O缓冲大小选项-SO-SNDBUF-amp-SO-RECVBUF"><a href="#2-I-O缓冲大小选项-SO-SNDBUF-amp-SO-RECVBUF" class="headerlink" title="2. I/O缓冲大小选项 SO_SNDBUF &amp; SO_RECVBUF"></a>2. I/O缓冲大小选项 SO_SNDBUF &amp; SO_RECVBUF</h2><ul>
<li>SO_RECVBUF是输入缓冲大小可选项</li>
<li>SO_SNDBUF是输出缓冲大小可选项</li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="keyword">int</span> snd_buf,rcv_buf,state;</span><br><span class="line">	<span class="keyword">socklen_t</span> len;</span><br><span class="line">	</span><br><span class="line">	sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_SNDBUF,(<span class="keyword">void</span> *)&amp;snd_buf,&amp;len);</span><br><span class="line">	</span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_RCVBUF,(<span class="keyword">void</span> *)&amp;rcv_buf,&amp;len);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input buffer size: %d \n"</span>, rcv_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Outupt buffer size: %d \n"</span>, snd_buf);</span><br><span class="line">	</span><br><span class="line">	snd_buf /= <span class="number">4</span>;</span><br><span class="line">	rcv_buf /= <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line">	state = setsockopt(sock,SOL_SOCKET,SO_SNDBUF,(<span class="keyword">void</span> *)&amp;snd_buf,<span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">	state = setsockopt(sock,SOL_SOCKET,SO_RCVBUF,(<span class="keyword">void</span> *)&amp;rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_SNDBUF,(<span class="keyword">void</span> *)&amp;snd_buf,&amp;len);</span><br><span class="line">	</span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_RCVBUF,(<span class="keyword">void</span> *)&amp;rcv_buf,&amp;len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input buffer size: %d \n"</span>, rcv_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Outupt buffer size: %d \n"</span>, snd_buf);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Input buffer size: 87380 </span></span><br><span class="line"><span class="comment">Outupt buffer size: 16384 </span></span><br><span class="line"><span class="comment">Input buffer size: 43690 </span></span><br><span class="line"><span class="comment">Outupt buffer size: 8192 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="3-地址再分配选项-SO-REUSEADDR-和Time-wait状态"><a href="#3-地址再分配选项-SO-REUSEADDR-和Time-wait状态" class="headerlink" title="3. 地址再分配选项 SO_REUSEADDR 和Time-wait状态"></a>3. 地址再分配选项 SO_REUSEADDR 和Time-wait状态</h2><p><strong>Time-wait状态</strong></p>
<ul>
<li>Time-wait状态出现在主动断开连接的一方，即先调用close()的一方</li>
<li>Time-wait状态的设置是为了确保最后一条ACK消息的准确到达</li>
<li>Time-wait并非只有优点</li>
</ul>
<p><strong>SO_REUSEADDR选项</strong></p>
<p>SO_REUSEADDR默认设置为0,意味着无法分配Time-wait状态下的套接字端口号。将该选项设置为1,则可将Time-wait状态下的套接字端口号重新分配给新的套接字。</p>
<h2 id="4-Nagle算法选项-TCP-NODELAY"><a href="#4-Nagle算法选项-TCP-NODELAY" class="headerlink" title="4. Nagle算法选项 TCP_NODELAY"></a>4. Nagle算法选项 TCP_NODELAY</h2><p><strong>Nagle算法</strong></p>
<ul>
<li>TCP默认使用Nagle算法交换数据，因此最大限度地进行缓冲，直到收到ACK。也就是只有收到前一数据的ACK消息时，才发送下一数据。</li>
<li>根据传输数据的特性，在网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。典型的是“传输大文件数据”。</li>
</ul>
<p><strong>禁用Nagle算法</strong></p>
<ul>
<li>如果有必要可以禁用Nagle算法</li>
<li>将TCP_NODELAY改为1即可禁用Nagle算法。</li>
</ul>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"># 网络编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/07/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(2)/" rel="prev" title="TCP/IP网络编程复习总结(2)">
                TCP/IP网络编程复习总结(2) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Keaper" />
            
              <p class="site-author-name" itemprop="name">Keaper</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/J-keaper" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-理解网络编程和套接字"><span class="nav-number">1.</span> <span class="nav-text">第一章 理解网络编程和套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-理解网络编程和套接字"><span class="nav-number">1.1.</span> <span class="nav-text">1. 理解网络编程和套接字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-基于linux的文件操作"><span class="nav-number">1.2.</span> <span class="nav-text">2. 基于linux的文件操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-文件操作"><span class="nav-number">1.3.</span> <span class="nav-text">3. 文件操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-套接字类型与协议设置"><span class="nav-number">2.</span> <span class="nav-text">第二章 套接字类型与协议设置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-创建套接字socket"><span class="nav-number">2.1.</span> <span class="nav-text">1. 创建套接字socket()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-参数domain-常用协议族"><span class="nav-number">2.2.</span> <span class="nav-text">2. 参数domain:常用协议族</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-参数type-套接字类型"><span class="nav-number">2.3.</span> <span class="nav-text">3. 参数type:套接字类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-参数protocol-协议类型"><span class="nav-number">2.4.</span> <span class="nav-text">4. 参数protocol:协议类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-地址族与数据序列"><span class="nav-number">3.</span> <span class="nav-text">第三章 地址族与数据序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IP地址与端口号"><span class="nav-number">3.1.</span> <span class="nav-text">1. IP地址与端口号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-地址信息的表示"><span class="nav-number">3.2.</span> <span class="nav-text">2. 地址信息的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-成员sin-family"><span class="nav-number">3.2.1.</span> <span class="nav-text">(1) 成员sin_family</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-成员sin-port"><span class="nav-number">3.2.2.</span> <span class="nav-text">(2) 成员sin_port</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-成员sin-addr"><span class="nav-number">3.2.3.</span> <span class="nav-text">(3) 成员sin_addr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-成员sin-zero"><span class="nav-number">3.2.4.</span> <span class="nav-text">(4) 成员sin_zero</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-sockaddr-in结构体的使用"><span class="nav-number">3.3.</span> <span class="nav-text">3. sockaddr_in结构体的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-网络字节序与地址变换"><span class="nav-number">3.4.</span> <span class="nav-text">4. 网络字节序与地址变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-网络地址的初始化与分配"><span class="nav-number">3.5.</span> <span class="nav-text">5. 网络地址的初始化与分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-将字符串信息转换为网络字节序的整数型值"><span class="nav-number">3.5.1.</span> <span class="nav-text">(1) 将字符串信息转换为网络字节序的整数型值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-常见的套接字创建过程中网络地址信息初始化方法"><span class="nav-number">3.5.2.</span> <span class="nav-text">(2) 常见的套接字创建过程中网络地址信息初始化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-向套接字分配网络地址-bind-函数"><span class="nav-number">3.5.3.</span> <span class="nav-text">(3) 向套接字分配网络地址 bind()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四、五章-基于TCP的服务端-客户端"><span class="nav-number">4.</span> <span class="nav-text">第四、五章 基于TCP的服务端&#x2F;客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-TCP服务器端的默认函数调用顺序"><span class="nav-number">4.1.</span> <span class="nav-text">1. TCP服务器端的默认函数调用顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-进入等待连接请求状态-listen-函数"><span class="nav-number">4.2.</span> <span class="nav-text">2. 进入等待连接请求状态 listen()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-受理客户端连接请求-connect-函数"><span class="nav-number">4.3.</span> <span class="nav-text">3. 受理客户端连接请求 connect()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-TCP客户端的默认函数调用顺序"><span class="nav-number">4.4.</span> <span class="nav-text">4. TCP客户端的默认函数调用顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-客户端发起连接请求connect-函数"><span class="nav-number">4.5.</span> <span class="nav-text">5. 客户端发起连接请求connect()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-第一个基于TCP的服务端-客户端—HelloWorld服务器"><span class="nav-number">4.6.</span> <span class="nav-text">6. 第一个基于TCP的服务端&#x2F;客户端—HelloWorld服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-基于TCP的服务端客户端函数调用关系"><span class="nav-number">4.7.</span> <span class="nav-text">7. 基于TCP的服务端客户端函数调用关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-迭代服务端-客户端"><span class="nav-number">4.8.</span> <span class="nav-text">8. 迭代服务端&#x2F;客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-迭代服务端函数调用顺序"><span class="nav-number">4.8.1.</span> <span class="nav-text">(1) 迭代服务端函数调用顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-迭代的回声服务端-客户端"><span class="nav-number">4.8.2.</span> <span class="nav-text">(2) 迭代的回声服务端&#x2F;客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-解决TCP不存在数据边界的问题"><span class="nav-number">4.9.</span> <span class="nav-text">9. 解决TCP不存在数据边界的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-TCP原理"><span class="nav-number">4.10.</span> <span class="nav-text">10. TCP原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-I-O缓冲"><span class="nav-number">4.10.1.</span> <span class="nav-text">(1) I&#x2F;O缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-套接字的连接"><span class="nav-number">4.10.2.</span> <span class="nav-text">(2) 套接字的连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-数据交换"><span class="nav-number">4.10.3.</span> <span class="nav-text">(3) 数据交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-断开套接字连接"><span class="nav-number">4.10.4.</span> <span class="nav-text">(4) 断开套接字连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-基于UDP的服务端-客户端"><span class="nav-number">5.</span> <span class="nav-text">第六章 基于UDP的服务端&#x2F;客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-UDP协议"><span class="nav-number">5.1.</span> <span class="nav-text">1. UDP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现基于UDP的服务端-客户端"><span class="nav-number">5.2.</span> <span class="nav-text">2. 实现基于UDP的服务端&#x2F;客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-基于UDP的数据I-O函数"><span class="nav-number">5.3.</span> <span class="nav-text">3. 基于UDP的数据I&#x2F;O函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-UDP的数据传输特性"><span class="nav-number">5.4.</span> <span class="nav-text">4. UDP的数据传输特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-未连接UDP套接字与已连接UDP套接字"><span class="nav-number">5.5.</span> <span class="nav-text">5. 未连接UDP套接字与已连接UDP套接字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-优雅地断开套接字连接"><span class="nav-number">6.</span> <span class="nav-text">第七章 优雅地断开套接字连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基于TCP的半关闭"><span class="nav-number">6.1.</span> <span class="nav-text">1. 基于TCP的半关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-针对半关闭的shutdown-函数"><span class="nav-number">6.2.</span> <span class="nav-text">2. 针对半关闭的shutdown()函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-域名及网络地址"><span class="nav-number">7.</span> <span class="nav-text">第八章 域名及网络地址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-域名系统"><span class="nav-number">7.1.</span> <span class="nav-text">1. 域名系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-利用域名获取IP地址"><span class="nav-number">7.2.</span> <span class="nav-text">2. 利用域名获取IP地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-利用IP地址获取域名"><span class="nav-number">7.3.</span> <span class="nav-text">3. 利用IP地址获取域名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-套接字的多种选项"><span class="nav-number">8.</span> <span class="nav-text">第九章 套接字的多种选项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-套接字选项"><span class="nav-number">8.1.</span> <span class="nav-text">1. 套接字选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-I-O缓冲大小选项-SO-SNDBUF-amp-SO-RECVBUF"><span class="nav-number">8.2.</span> <span class="nav-text">2. I&#x2F;O缓冲大小选项 SO_SNDBUF &amp; SO_RECVBUF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-地址再分配选项-SO-REUSEADDR-和Time-wait状态"><span class="nav-number">8.3.</span> <span class="nav-text">3. 地址再分配选项 SO_REUSEADDR 和Time-wait状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Nagle算法选项-TCP-NODELAY"><span class="nav-number">8.4.</span> <span class="nav-text">4. Nagle算法选项 TCP_NODELAY</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keaper</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
