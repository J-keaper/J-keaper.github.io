<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32%C3%9732.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16%C3%9716.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Keaper&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Keaper&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Keaper">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="http://yoursite.com/page/6/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Keaper's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keaper's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/08/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/7.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/7.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="url">
                  剑指offer - 重建二叉树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-08 23:00:00" itemprop="dateCreated datePublished" datetime="2017-08-08T23:00:00+00:00">2017-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>二叉树前序遍历：根-左子树-右子树，二叉树中序遍历：左子树-根-右子树，根据根节点的位置，可以将左右技子树分开，然后递归操作即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> pos = find(vin.begin(),vin.end(),pre[<span class="number">0</span>])-vin.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lpre,lvin,rpre,rvin;</span><br><span class="line">        <span class="comment">//如果pos = 0，表示左子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            lpre = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(pre.begin()+<span class="number">1</span>,pre.begin()+pos+<span class="number">1</span>);</span><br><span class="line">            lvin = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vin.begin(),vin.begin()+pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pos = pre.size-1 ,表示右子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(pos&lt;pre.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            rpre = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(pre.begin()+pos+<span class="number">1</span>,pre.end());</span><br><span class="line">            rvin = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vin.begin()+pos+<span class="number">1</span>,vin.end());</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = reConstructBinaryTree(lpre,lvin);</span><br><span class="line">        root-&gt;right = reConstructBinaryTree(rpre,rvin);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已知中序遍历和 前序或者后后续遍历 ，都可以唯一确定一棵二叉树，但是已知前序和后序无法确定。<br>如果要得到后序遍历序列，只需要在返回前打印或者存储根节点的值即可。<br>如果要得到层次遍历序列，可以将树建好之后用队列实现一遍。<br>还有一种方法，就是按照数组存储满二叉树的思想，用一个map记录，对应下标上的值，由于是map，没有节点的地方map也不会有值，不用担心存不下所有的点，但是这种方法有一个缺点，由于map key类型的限制，使用会有一定限制，比如int的key类型，只能存储31层左右的树，long long 类推。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; levelTravelMap;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        levelTravelMap[index]=pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> pos = find(vin.begin(),vin.end(),pre[<span class="number">0</span>])-vin.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lpre,lvin,rpre,rvin;</span><br><span class="line">        <span class="comment">//如果pos = 0，表示左子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            lpre = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(pre.begin()+<span class="number">1</span>,pre.begin()+pos+<span class="number">1</span>);</span><br><span class="line">            lvin = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vin.begin(),vin.begin()+pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pos = pre.size-1 ,表示右子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(pos&lt;pre.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            rpre = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(pre.begin()+pos+<span class="number">1</span>,pre.end());</span><br><span class="line">            rvin = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vin.begin()+pos+<span class="number">1</span>,vin.end());</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = reConstructBinaryTree(lpre,lvin,index&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        root-&gt;right = reConstructBinaryTree(rpre,rvin,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/6.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/6.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/" itemprop="url">
                  剑指offer - 从尾到头打印链表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-07 23:19:00" itemprop="dateCreated datePublished" datetime="2017-08-07T23:19:00+00:00">2017-08-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.nowcoder.com/questionTerminal/d0267f7f55b3412ba93bd35cfa8e8035" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/d0267f7f55b3412ba93bd35cfa8e8035</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>从尾到头，要访问到链表的尾节点，必须从头开始访问遍历整个链表。在不增加指针的情况下，只能遍历的时候存储每个节点的值，然后倒序输出，可以用栈来实现。当然不存也可以，递归的访问，输出每个点之前先将之后的节点输出。其实也用到了栈，都免不了O(N)的空间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            st.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            ans.push_back(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        dfs(ans,head);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans,ListNode * head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(ans,head-&gt;next);</span><br><span class="line">        ans.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/5.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/5.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/" itemprop="url">
                  剑指offer - 替换空格
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-07 22:20:00" itemprop="dateCreated datePublished" datetime="2017-08-07T22:20:00+00:00">2017-08-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.nowcoder.com/questionTerminal/4060ac7e3e404ad1a894ef3e17650423" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/4060ac7e3e404ad1a894ef3e17650423</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>从头到尾依次复制，如果遇到空格将后面的字符依次后移，当然这很低效，最欢时间复杂度O(N*N)。可以用O(N)的额外空间来依次复制，遇到空格替换%20，时间复杂度O(N)。其实可以不用花这O(N)的空间，我们可以先计算出恭需要增加多大的空间，然后从尾到头填充字符，因为，长度不可能比原来短，所以直接在原来的数组空间操作即可，不用担心覆盖。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> spaceCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>) spaceCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=length+spaceCount*<span class="number">2</span>;</span><br><span class="line">        str[j--] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                str[j--] = <span class="string">'0'</span>;</span><br><span class="line">                str[j--] = <span class="string">'2'</span>;</span><br><span class="line">                str[j--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[j--] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h4><p>有两个有序的数组A和B，要将B插入到A中使得整个数组仍然有序。<br>其实是一样的，计算出两个数组的总长度，然后在A数组中从后往前依次填充，比较A数组和B数组将大的填入。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/4.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/4.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" itemprop="url">
                  剑指offer - 二维数组中的查找
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-06 23:20:00" itemprop="dateCreated datePublished" datetime="2017-08-06T23:20:00+00:00">2017-08-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>依次扫描的方法在此不表。<br>对于这样的四个数，a &lt; b，c &lt; d，a &lt; c，b &lt; d<br><img src="https://blog-picture.nos-eastchina1.126.net/formula-0006.gif" alt=""><br>所以a &lt; c &lt; d，a &lt; b &lt; d 。<br>由上述关系我们可以得到一种方法。从左下角出发，如果小于目标数则应该向右继续寻找，否则向上寻找，一直到等于目标数。如果越界则表示没有没有找到。<br>当然可以从右上角来寻找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>  target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">array</span>.size()<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span>&lt;=i&amp;&amp;i&lt;<span class="built_in">array</span>.size()&amp;&amp;<span class="number">0</span>&lt;=j&amp;&amp;j&lt;<span class="built_in">array</span>[i].size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="built_in">array</span>[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j]) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j]) i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E5%89%91%E6%8C%87offer/3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" itemprop="url">
                  剑指offer - 数组中重复的数字
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-06 23:00:00" itemprop="dateCreated datePublished" datetime="2017-08-06T23:00:00+00:00">2017-08-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.nowcoder.com/questionTerminal/623a5ac0ea5b4e5f95552655361ae0a8" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/623a5ac0ea5b4e5f95552655361ae0a8</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是2或3。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ul>
<li>解法一：排序判断相邻的数字是否相等。时间复杂度O(NLogN)，空间复杂度O(1)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        sort(numbers,numbers+length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[i<span class="number">-1</span>])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>解法二：用hash表存每个数字出现的次数，当一个数字出现的次数大于1时，返回结果。时间复杂度O(N)，空间复杂度O(N)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            cnt[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[numbers[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>解法三：给出的数都是1~N之间的数，所以如果我们将数组重排是的每个数都回到自己的位置上，即 i=numbers[i] ,如果有重复数字，则必定有数字在多个位置出现。<br>重排数组对每个数字numbers[i]，如果i=numbers[i]，则表示已经满足条件，继续下一个，如果不等于比较numbers[ numbers[i] ]和numbers[i] ，如果相等，则找到重复的数字，如果不相等，则交换numbers[i]和numbers[ numbers[i] ]，此时numbers[i] 位置上已经归位，继续比较交换过来的数字，直到找到重复数字或者i=numbers[i]。<br>时间复杂度：O(N)，虽然是两层循环，但是，每个数字最多交换两次就能回到自己的位置，时间复杂度O(1)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers[i],numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h3>在一个长度为 n+1 的数组里的所有数字都在1到n的范围内。 所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4></li>
<li>上述解法一仍然适用，只不过需要增加O(N)的空间复杂度用来存储辅助数组，存放原数组的副本。</li>
<li>解法二也仍然适用。复杂度不变。</li>
<li>解法三也可以，同样需要O(N)的辅助空间。实际上，由于不能原来的数组，可以直接在复制到辅助数组时，便将其放到对应的位置上，如果有发现该位置已经有数字，则找到重复数字。时间杂度O(N)，空间复杂度O(N)。</li>
<li>如何能达到O(1)空间呢？不能用哈希表存数字出现的次数，我们只能计算每个数时，都对全数组扫描一遍，这样是O(N*N)时间复杂度+O(1)空间复杂度。还有优化余地吗？实际上我们可以发现，如果1~m之间的数的个数超过m，则必定有重复的数字（鸽巢原理），这样我们可以利用二分法，将范围不断缩小。直到范围为1。时间复杂度O(NLogN)，空间复杂度O(1)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = getCount(numbers,length,left,mid);</span><br><span class="line">            <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>]=left;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;(mid-left+<span class="number">1</span>))</span><br><span class="line">                right=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">(<span class="keyword">int</span> *numbers,<span class="keyword">int</span> length,<span class="keyword">int</span> left,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&gt;=left&amp;&amp;numbers[i]&lt;=end)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/02/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/leetcode/leetcode%206.%20ZigZag%20Conversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/leetcode/leetcode%206.%20ZigZag%20Conversion/" itemprop="url">
                  leetcode 6. ZigZag Conversion
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 18:47:00" itemprop="dateCreated datePublished" datetime="2017-07-02T18:47:00+00:00">2017-07-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="https://leetcode.com/problems/zigzag-conversion/#/description" target="_blank" rel="noopener">https://leetcode.com/problems/zigzag-conversion/#/description</a></p>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给一个字符串，要求将字符串排列成锯齿状，然后按行从左到右输出。如下图，原来的字符串顺序为： BFGAHIDJKCLME，按行读就是BDEFIJMGHKLAC。<br><img src="https://blog-picture.nos-eastchina1.126.net/picture0004.png" alt="图示"></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>找规律即可，按行来看相邻两个点的距离分为两个，假设为a和b，第 i 行为[2<em>(n-i-1)，2</em>i]，第一行相当于b为0，第二行相当于a为0，距离为零表示两点重合，不考虑。依次输出。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">2</span>*(numRows-i<span class="number">-1</span>),b=<span class="number">2</span>*i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;s.size();)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a)&#123;</span><br><span class="line">                    ans+=s[j];</span><br><span class="line">                    j+=a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=s.size()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                    ans+=s[j];</span><br><span class="line">                    j+=b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sol.convert(str,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/07/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/07/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(2)/" itemprop="url">
                  TCP/IP网络编程复习总结(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-07 18:47:00" itemprop="dateCreated datePublished" datetime="2017-06-07T18:47:00+00:00">2017-06-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十章-多进程服务器端"><a href="#第十章-多进程服务器端" class="headerlink" title="第十章 多进程服务器端"></a>第十章 多进程服务器端</h1><h2 id="1-进程该概念及应用"><a href="#1-进程该概念及应用" class="headerlink" title="1. 进程该概念及应用"></a>1. 进程该概念及应用</h2><ul>
<li><p>并发服务端实现方法</p>
<ul>
<li>多进程服务器</li>
<li>多路复用服务器</li>
<li>多线程服务器</li>
</ul>
</li>
<li><p>创建进程 fork()函数</p>
<ul>
<li><p>头文件：<code>&lt;unistd.h&gt;</code></p>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：空</p>
</li>
<li><p>返回值：在父进程中fork返回子进程ID，在子进程中返回0</p>
</li>
</ul>
</li>
<li><p>fork函数示例</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> lval =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        lval+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        lval-=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)	<span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child proc : %d \n"</span>,lval);</span><br><span class="line">    <span class="keyword">else</span> 		<span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent proc : %d \n"</span>,lval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">parent proc : 18 </span></span><br><span class="line"><span class="comment">child proc : 22</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="2-进程和僵尸进程"><a href="#2-进程和僵尸进程" class="headerlink" title="2. 进程和僵尸进程"></a>2. 进程和僵尸进程</h2><ul>
<li>产生僵尸进程的原因：向exit函数传递的参数值和main函数中的return语句返回的值都会传递给操作系统。但操作系统不会销毁子进程直到把这些值传递给产生该进程的父进程。处于这种状态的进程就是僵尸进程。</li>
<li>销毁僵尸进程的方法：向创建子进程的父进程传递子进程的exit参数值和return语句的返回值。</li>
</ul>
<h2 id="3-销毁僵尸进程"><a href="#3-销毁僵尸进程" class="headerlink" title="3. 销毁僵尸进程"></a>3. 销毁僵尸进程</h2><h3 id="1-wait函数"><a href="#1-wait函数" class="headerlink" title="(1) wait函数"></a>(1) wait函数</h3><ul>
<li><p>头文件：<code>&lt;sys/wait.h&gt;</code></p>
</li>
<li><p>功能：等待子进程返回</p>
</li>
<li><p>原型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>  * statloc)</span></span>;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：调用此函数时，如果已有子进程终止，那么子进程终止时传递的返回值将保存到参数所指的内存空间。但参数指向的单元有其他信息，故需要通过宏进行分离。</p>
<ul>
<li>WIFEXITED 子进程正常终止是返回true</li>
<li>WEXITSTATUS 返回子进程的返回值</li>
</ul>
</li>
<li><p>返回值：成功返回终止的子进程ID，失败返回-1<br><em>调用wait函数时，如果没有已经终止的子进程，那么程序将<strong>阻塞</strong>直到有子进程终止。</em></p>
</li>
<li><p>示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid=fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child PID : %d \n"</span>,pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child PID : %d \n"</span>,pid);</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child send: %d \n"</span>,WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child send: %d \n"</span>,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Child PID : 4775 </span></span><br><span class="line"><span class="comment">Child PID : 4776 </span></span><br><span class="line"><span class="comment">Child send: 3 </span></span><br><span class="line"><span class="comment">Child send: 7 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-waitpid函数"><a href="#2-waitpid函数" class="headerlink" title="(2) waitpid函数"></a>(2) waitpid函数</h3><ul>
<li><p>头文件：<code>&lt;sys/wait.h&gt;</code></p>
</li>
<li><p>原型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> * statloc, inoptions)</span></span>;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>pid 等待终止的目标子进程ID，若传递-1，则等待任意子进程终止</li>
<li>statloc 与wait函数意义相同</li>
<li>options 传递头文件<code>&lt;sys/wait.h&gt;</code>中的常量WNOHANG，即时没有终止的子进程也<strong>不会进入阻塞状态</strong>，而是返回0并退出函数。</li>
</ul>
</li>
<li><p>返回值：<br>  成功是返回终止的子进程ID（或者0），失败时返回-1</p>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!waitpid(<span class="number">-1</span>,&amp;status,WNOHANG))</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"sleep 3 sec."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child send %d \n"</span>,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">sleep 3 sec.</span></span><br><span class="line"><span class="comment">sleep 3 sec.</span></span><br><span class="line"><span class="comment">sleep 3 sec.</span></span><br><span class="line"><span class="comment">sleep 3 sec.</span></span><br><span class="line"><span class="comment">sleep 3 sec.</span></span><br><span class="line"><span class="comment">Child send 24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-信号处理"><a href="#4-信号处理" class="headerlink" title="4. 信号处理"></a>4. 信号处理</h2><h3 id="1-信号"><a href="#1-信号" class="headerlink" title="(1)信号"></a>(1)信号</h3><ul>
<li>信号是在特定事件发生时由操作系统向进程发送的信息</li>
</ul>
<h3 id="2-signal函数"><a href="#2-signal函数" class="headerlink" title="(2)signal函数"></a>(2)signal函数</h3><ul>
<li><p>功能：注册信号</p>
</li>
<li><p>头文件：<code>&lt;signal.h&gt;</code></p>
</li>
<li><p>原型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo,<span class="keyword">void</span>(*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>func : 信号发出时要调用的函数，该函数是参数类型为int，返回void型的函数ji</li>
<li>signo: 需要处理的信号</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信号</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIGALRM</td>
<td align="center">已到通过调用alarm函数注册的时间</td>
</tr>
<tr>
<td align="center">SIGINT</td>
<td align="center">程序终止信号，通常是输入Ctrl+C</td>
</tr>
<tr>
<td align="center">SIGCHLD</td>
<td align="center">子进程终止</td>
</tr>
</tbody></table>
<ul>
<li>返回值：返回之前注册的函数指针（参数类型为int，返回void型的函数）</li>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"time out"</span>);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keycontrol</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Ctrl+C pressed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM,timeout);</span><br><span class="line">    signal(SIGINT,keycontrol);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"wait..."</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">time out</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">^CCtrl+C pressed</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">time out</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><em>注：信号的产生会唤醒由于调用sleep函数而进入阻塞状态的进程，进程一旦被唤醒就不会再进入睡眠状态。</em></p>
<h3 id="3-alarm函数"><a href="#3-alarm函数" class="headerlink" title="(3) alarm函数"></a>(3) alarm函数</h3><ul>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：如果传递一个正整型参数，则相应时间到达（以秒为单位）后将产生SIGALRM信号。若传递参数0，则取消之前的对 SIGNAL信号的预约。</p>
</li>
<li><p>返回值：返回0或者，以秒为单位的距SIGNAL信号发生所剩的时间</p>
</li>
</ul>
<h3 id="4-sigaction函数"><a href="#4-sigaction函数" class="headerlink" title="(4) sigaction函数"></a>(4) sigaction函数</h3><ul>
<li><p>原型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span> <span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>signo 传递信号信息</li>
<li>act 对应于第一个参数的信号处理函数信息。</li>
<li>oldact 通过此参数获取之前注册的信号处理函数指针，若不处理则传递0</li>
</ul>
</li>
<li><p>返回值：成功返回0,失败返回-1</p>
</li>
<li><p>struct结构体:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler) (<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig==SIGALRM)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Time out"</span>);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//注册信号</span></span><br><span class="line">    act.sa_handler=timeout;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags=<span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM,&amp;act,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"wait..."</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">Time out</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">Time out</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">Time out</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-利用信号处理技术消灭僵尸进程"><a href="#5-利用信号处理技术消灭僵尸进程" class="headerlink" title="(5) 利用信号处理技术消灭僵尸进程"></a>(5) 利用信号处理技术消灭僵尸进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG);</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Remove proc id : %d \n"</span>,pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child send : %d \n"</span>,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler=read_child;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags=<span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD,&amp;act,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child PID : %d \n"</span>,pid);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"wait..."</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Child PID : 5119 </span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">Remove proc id : 5119 </span></span><br><span class="line"><span class="comment">Child send : 12 </span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-基于多任务的并发服务器"><a href="#5-基于多任务的并发服务器" class="headerlink" title="5. 基于多任务的并发服务器"></a>5. 基于多任务的并发服务器</h2><ul>
<li>为每个客户端都创建一个进程提供服务</li>
<li>实现并发服务器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Remove proc id ; %d \n"</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock,clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_child;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGCHLD,&amp;act,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"sigaction() error"</span>);</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    serv_sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">    <span class="comment">//地址初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock,(struct sockaddr*) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">        clnt_sock = accept(serv_sock,(struct sockaddr*) &amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">        <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"new connection !"</span>);</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(serv_sock); <span class="comment">//子进程关闭监听套接字</span></span><br><span class="line">            <span class="keyword">int</span> str_len;</span><br><span class="line">            <span class="keyword">while</span>((str_len=<span class="built_in">read</span>(clnt_sock,buf,BUF_SIZE))!=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">write</span>(clnt_sock,buf,str_len);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"client disconnected !"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);  <span class="comment">//父进程关闭数据传输的套接字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="6-分割TCP的I-O程序"><a href="#6-分割TCP的I-O程序" class="headerlink" title="6. 分割TCP的I/O程序"></a>6. 分割TCP的I/O程序</h2><h1 id="第十一章-进程间通信"><a href="#第十一章-进程间通信" class="headerlink" title="第十一章 进程间通信"></a>第十一章 进程间通信</h1><h2 id="1-进程件间通信的基本概念"><a href="#1-进程件间通信的基本概念" class="headerlink" title="1. 进程件间通信的基本概念"></a>1. 进程件间通信的基本概念</h2><p><strong>创建管道 pipe() 函数</strong></p>
<ul>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>filededs[0] 通过管道接受数据使用的文件描述符，即管道出口</li>
<li>filededs[1] 通过管道发送数据使用的文件描述符，即管道入口</li>
</ul>
</li>
<li><p>返回值：成功返回0,失败返回-1</p>
</li>
</ul>
<p><strong>通过管道实现进程间通信</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">	pipe(fds);</span><br><span class="line">	<span class="keyword">char</span> str[]=<span class="string">"Who are you?"</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">write</span>(fds[<span class="number">1</span>],str,<span class="keyword">sizeof</span>(str));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(fds[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">puts</span>(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Who are you?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>通过管道进行进程间双向通信</strong></p>
<p>一个管道在需要双向通信时会产生混乱，所以双向通信时需要两个管道用于不同方向的数据传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fds1[<span class="number">2</span>],fds2[<span class="number">2</span>];</span><br><span class="line">	pipe(fds1);</span><br><span class="line">	pipe(fds2);</span><br><span class="line">	<span class="keyword">char</span> str1[]=<span class="string">"How are you?"</span>;</span><br><span class="line">	<span class="keyword">char</span> str2[]=<span class="string">"I'm fine."</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pid_t</span> pid =fork();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">write</span>(fds1[<span class="number">1</span>],str1,<span class="keyword">sizeof</span>(str1));</span><br><span class="line">		<span class="built_in">read</span>(fds2[<span class="number">0</span>],buf,<span class="number">30</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child proc print: %s \n"</span>,buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(fds1[<span class="number">0</span>],buf,<span class="number">30</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Parent proc print: %s \n"</span>,buf);</span><br><span class="line">		<span class="built_in">write</span>(fds2[<span class="number">1</span>],str2,<span class="keyword">sizeof</span>(str2));</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Parent proc print: How are you? </span></span><br><span class="line"><span class="comment">Child proc print: I'm fine.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="第十二章-I-O复用"><a href="#第十二章-I-O复用" class="headerlink" title="第十二章 I/O复用"></a>第十二章 I/O复用</h1><p>多进程服务器端中，创建进程的代价较大，进程间相互通信也相对复杂。</p>
<h2 id="1-select函数"><a href="#1-select函数" class="headerlink" title="1. select函数"></a>1. select函数</h2><ul>
<li>使用selct函数可以将多个文件描述符集中到一起统一监视。</li>
<li>slect函数的调用顺序：<br><br>  <strong>设置文件描述符，指定监视范围，设置超时 ===&gt; 指定监视范围 ===&gt; 调用select函数 ===&gt; 查看调用结果</strong></li>
</ul>
<p><strong>设置文件描述符</strong></p>
<ul>
<li>select函数可以同时监视多个文件描述符，可以视为监视多个套接字。</li>
<li>首先要将监视的文件描述符集中在一起，集中时按照监视项（接受，传输，异常）进行区分。</li>
<li>fd_set数组变量，每一位状态都表示文件描述符为此下标的文件或者套接字是否处于监视范围，1表示是监视对象，0表示不是。</li>
<li>操作fd_set的宏</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FD_ZERO(fd_set *fdset)</td>
<td align="center">将fd_set变量的所有位初始化为0</td>
</tr>
<tr>
<td align="center">FD_SET(int fd,fd_set *fdset)</td>
<td align="center">在参数fdset指向的变量中注册文件描述符fd的信息，即将该位置为1</td>
</tr>
<tr>
<td align="center">FD_CLR(int fd,fd_set *fdset)</td>
<td align="center">从参数fdset指向的变量中清除文件描述符fd的信息，即将该位置为0</td>
</tr>
<tr>
<td align="center">FD_ISSET(int fd,fd_set *fdset)</td>
<td align="center">若参数fdset指向的变量中包含文件描述符fd的信息，则返回true</td>
</tr>
</tbody></table>
<p><strong>设置监视范围及超时select函数</strong></p>
<ul>
<li><p>头文件<code>&lt;sys/select.h&gt;</code></p>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> maxfd, fd_set *readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">       fd_set *writefds, fd_set *exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数：</p>
<ul>
<li>maxfd 监视对象文件描述符的数量</li>
<li>readfds 将所有关注”是否存在待读取数据”的文件描述符注册到fd_set型变量，并传递其地址值</li>
<li>writefds 将所有关注”是否可传输无阻塞数据”的文件描述符注册到fd_set型变量，并传递其地址值</li>
<li>exceptfds 将所有关注”是否发生异常”的文件描述符注册到fd_set型变量，并传递其地址值</li>
<li>timeout 设置超时时间</li>
</ul>
</li>
<li><p>timeval结构体</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> sec;	“”	<span class="comment">/* Seconds.  */</span></span><br><span class="line">    <span class="keyword">long</span> usec;	<span class="comment">/* Microseconds.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：发生错误返回-1,超时返回0。发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数量。</p>
</li>
</ul>
<p><strong>调用sselect函数后查看返回结果</strong></p>
<p>select函数调用完成后，向其传递的fd_set变量中将发生变化。原来为1的所有位均变为0,但发生变化的文件描述符除外。也就是值为1的位置上的文件描述副发生了变化。</p>
<p><strong>select函数调用示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fd_set reads,temps;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>];</span><br><span class="line">	</span><br><span class="line">	FD_ZERO(&amp;reads);</span><br><span class="line">	FD_SET(<span class="number">0</span>,&amp;reads);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temps = reads;</span><br><span class="line">		timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">		timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> result = select(<span class="number">1</span>,&amp;temps,<span class="number">0</span>,<span class="number">0</span>,&amp;timeout);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(result==<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"select() error!"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"timeout!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(FD_ISSET(<span class="number">0</span>,&amp;temps))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> <span class="built_in">strlen</span>=<span class="built_in">read</span>(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">				buf[<span class="built_in">strlen</span>]=<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"message from console: %s"</span>,buf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">message from console: hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">message from console: hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">message from console: world</span></span><br><span class="line"><span class="comment">timeout!</span></span><br><span class="line"><span class="comment">timeout!</span></span><br><span class="line"><span class="comment">timeout!</span></span><br><span class="line"><span class="comment">timeout!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>实现I/O复用的服务器端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> serv_sock,clnt_sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">	<span class="comment">//监视范围fd_set变量</span></span><br><span class="line">	fd_set reads,cp_reads;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字变量</span></span><br><span class="line">	serv_sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//地址信息初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(bind(serv_sock,(struct sockaddr*) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line">	</span><br><span class="line">	FD_ZERO(&amp;reads);</span><br><span class="line">	FD_SET(serv_sock,&amp;reads);	<span class="comment">//监视服务端套接字</span></span><br><span class="line">	<span class="keyword">int</span> fd_max=serv_sock+<span class="number">1</span>;		<span class="comment">//设置最大监视数量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cp_reads = reads;		<span class="comment">//备份fd_set,因为调用select函数后，fd_set会被清空</span></span><br><span class="line">		timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">		timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line">		<span class="keyword">int</span> fd_num;</span><br><span class="line">		<span class="keyword">if</span>((fd_num=select(fd_max+<span class="number">1</span>,&amp;cp_reads,<span class="number">0</span>,<span class="number">0</span>,&amp;timeout))==<span class="number">-1</span>)	<span class="comment">//调用select函数</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(fd_num==<span class="number">0</span>)	<span class="comment">//超时</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;fd_max+<span class="number">1</span>;i++)		</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(FD_ISSET(i,&amp;cp_reads))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==serv_sock) <span class="comment">//服务端监听套接字发生变化说明，有新的连接请求</span></span><br><span class="line">				&#123;</span><br><span class="line">					clnt_sock = accept(serv_sock,(struct sockaddr*) &amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">					FD_SET(clnt_sock,&amp;reads);	<span class="comment">//将新连接置于监控范围内</span></span><br><span class="line">					<span class="keyword">if</span>(fd_max&lt;clnt_sock)</span><br><span class="line">						fd_max=clnt_sock;		<span class="comment">//更新最大监控数量</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"Connected client : %d \n"</span>,clnt_sock);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> 			<span class="comment">//用于数据传输的套接字发生变化，说明有数据需要读取</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> str_len=<span class="built_in">read</span>(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">					<span class="keyword">if</span>(str_len==<span class="number">0</span>)		<span class="comment">//客户端关闭连接</span></span><br><span class="line">					&#123;		</span><br><span class="line">						FD_CLR(i,&amp;reads);		<span class="comment">//移出监控范围</span></span><br><span class="line">						<span class="built_in">close</span>(i);			</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"Closed clinet : %d \n"</span>,i);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> </span><br><span class="line">						<span class="built_in">write</span>(i,buf,str_len);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(serv_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第十三章-多种I-O函数"><a href="#第十三章-多种I-O函数" class="headerlink" title="第十三章 多种I/O函数"></a>第十三章 多种I/O函数</h1><h2 id="1-send-amp-recv-函数"><a href="#1-send-amp-recv-函数" class="headerlink" title="1. send() &amp; recv()函数"></a>1. send() &amp; recv()函数</h2><p><strong>send()</strong></p>
<ul>
<li>头文件：<code>&lt;sys/socket.h&gt;</code></li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sockfd 表示与发送数据连接的套接字文件描述符</li>
<li>buf 待发送数据的缓冲地址值</li>
<li>nbytes 待传输的字节数</li>
<li>flags 可选项</li>
</ul>
</li>
<li>返回值：成功返回发送的字节数，失败返回-1</li>
</ul>
<p><strong>recv()</strong></p>
<ul>
<li>头文件：<code>&lt;sys/socket.h&gt;</code></li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：    <ul>
<li>sockfd 表示与接受数据连接的套接字文件描述符</li>
<li>buf 保存接受数据的缓冲区地址值</li>
<li>nbytes 可接收的最大字节数</li>
<li>flags可选项</li>
</ul>
</li>
<li>返回值 ：成功返回收到的字节数（收到EOF返回0），失败返回-1</li>
</ul>
<p><strong>flags选项</strong></p>
<table>
<thead>
<tr>
<th align="center">flags</th>
<th align="center">说明</th>
<th align="center">recv</th>
<th align="center">send</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MSG_OOB</td>
<td align="center">发送或接收带外数据(Out-of-band data)</td>
<td align="center">•</td>
<td align="center">•</td>
</tr>
<tr>
<td align="center">MSG_PEEK</td>
<td align="center">验证输入缓冲是否存在待接受的数据</td>
<td align="center">•</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">MSG_DONTROUTE</td>
<td align="center">绕过路由表查找，在本地网络中寻找目的地</td>
<td align="center"></td>
<td align="center">•</td>
</tr>
<tr>
<td align="center">MSG_DONTWAIT</td>
<td align="center">调用I/O函数时不阻塞，用于使用非阻塞I/O</td>
<td align="center">•</td>
<td align="center">•</td>
</tr>
<tr>
<td align="center">MSG_WAITALL</td>
<td align="center">防止函数返回，直到接受全部请求的字节数</td>
<td align="center">•</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>MSG_OOB选项：发送紧急消息</strong></p>
<ul>
<li>MSG_OOB可选项用于发送“带外数据”紧急消息。</li>
<li>示例:</li>
</ul>
<p>发送端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">... 		<span class="comment">//头文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_adr</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sock=socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;recv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_adr));</span><br><span class="line">	recv_adr.sin_family=AF_INET;</span><br><span class="line">	recv_adr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	recv_adr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;recv_adr, <span class="keyword">sizeof</span>(recv_adr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"connect() error!"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">write</span>(sock,<span class="string">"123"</span>,<span class="built_in">strlen</span>(<span class="string">"123"</span>));</span><br><span class="line">	send(sock,<span class="string">"4"</span>,<span class="built_in">strlen</span>(<span class="string">"4"</span>),MSG_OOB);  <span class="comment">//发送带外数据</span></span><br><span class="line">	<span class="built_in">write</span>(sock,<span class="string">"567"</span>,<span class="built_in">strlen</span>(<span class="string">"567"</span>));</span><br><span class="line">	send(sock,<span class="string">"890"</span>,<span class="built_in">strlen</span>(<span class="string">"890"</span>),MSG_OOB);		<span class="comment">//发送带外数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接受端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">...			<span class="comment">//头文件省略</span></span><br><span class="line"><span class="keyword">int</span> acpt_sock;</span><br><span class="line"><span class="keyword">int</span> recv_sock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urg_handler</span><span class="params">(<span class="keyword">int</span> sig)</span>           <span class="comment">//带外数据处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> str_len;</span><br><span class="line">	<span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">	str_len=recv(recv_sock,buf,<span class="keyword">sizeof</span>(buf),MSG_OOB);</span><br><span class="line">	buf[str_len]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Uegent message : %s \n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_adr</span>, <span class="title">serv_adr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> str_len, state;</span><br><span class="line">	<span class="keyword">socklen_t</span> serv_adr_sz;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	act.sa_handler = urg_handler;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	acpt_sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;recv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_adr));</span><br><span class="line">	recv_adr.sin_family=AF_INET;</span><br><span class="line">	recv_adr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	recv_adr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(bind(acpt_sock, (struct sockaddr*)&amp;recv_adr, <span class="keyword">sizeof</span>(recv_adr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	<span class="built_in">listen</span>(acpt_sock, <span class="number">5</span>);</span><br><span class="line">	serv_adr_sz=<span class="keyword">sizeof</span>(serv_adr);</span><br><span class="line">	recv_sock=accept(acpt_sock, (struct sockaddr*)&amp;serv_adr, &amp;serv_adr_sz);</span><br><span class="line">	</span><br><span class="line">	fcntl(recv_sock,F_SETOWN,getpid());     <span class="comment">//为带外数据指定处理进程</span></span><br><span class="line">	state=sigaction(SIGURG,&amp;act,<span class="number">0</span>);         <span class="comment">//为SIGURG信号注册函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((str_len=recv(recv_sock,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>))!=<span class="number">0</span>)   <span class="comment">//正常读取普通数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		buf[str_len]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">puts</span>(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">close</span>(recv_sock);</span><br><span class="line">	<span class="built_in">close</span>(acpt_sock);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>检查输入缓冲</strong></p>
<ul>
<li>设置MSG_PEEK选项并调用recv函数时，即使读取了输入缓冲中的数据也不会删除。因此该选项经常与MSG_DONTWAIT合作，用于调用以非阻塞方式验证待读数据的存在与否的函数。</li>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">... 			<span class="comment">//头文件省略</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> acpt_sock, recv_sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">acpt_adr</span>, <span class="title">recv_adr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> str_len, state;</span><br><span class="line">	<span class="keyword">socklen_t</span> recv_adr_sz;</span><br><span class="line">	<span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	acpt_sock=socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;acpt_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(acpt_adr));</span><br><span class="line">	acpt_adr.sin_family=AF_INET;</span><br><span class="line">	acpt_adr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	acpt_adr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	</span><br><span class="line">  	<span class="keyword">if</span>(bind(acpt_sock, (struct sockaddr*)&amp;acpt_adr, <span class="keyword">sizeof</span>(acpt_adr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	<span class="built_in">listen</span>(acpt_sock, <span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	recv_adr_sz=<span class="keyword">sizeof</span>(recv_adr);</span><br><span class="line">	recv_sock=accept(acpt_sock, (struct sockaddr*)&amp;recv_adr, &amp;recv_adr_sz);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//查看缓冲是否有数据，读完 不会删除缓冲区</span></span><br><span class="line">		str_len=recv(recv_sock,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,MSG_PEEK|MSG_DONTWAIT); 		</span><br><span class="line">		<span class="keyword">if</span>(str_len&gt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[str_len]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Buffering %d bytes: %s \n"</span>, str_len, buf);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//正常读取，读完删除</span></span><br><span class="line">	str_len = recv(recv_sock,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	buf[str_len]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Readagin : %s \n"</span>,buf);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(acpt_sock);</span><br><span class="line">	<span class="built_in">close</span>(recv_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-readv-amp-writev函数"><a href="#2-readv-amp-writev函数" class="headerlink" title="2. readv &amp; writev函数"></a>2. readv &amp; writev函数</h2><p>通过writev函数可以将分散保存在多个缓冲中的数据一并发送，通过readv函数可以由多个缓冲分别接受。</p>
<p><strong>writev函数</strong></p>
<ul>
<li>头文件：<code>&lt;sys/uio.h&gt;</code></li>
<li>原型：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd 表示数据传输对象的文件描述符</li>
<li>iov iov结构体数组的地址值</li>
<li>iovcnt 第二个参数的数组长度</li>
</ul>
</li>
<li>返回值：成功时返回 发送的字节数，失败返回-1</li>
<li>iovec结构体  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base;	<span class="comment">/* Pointer to data.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;	<span class="comment">/* Length of data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">	<span class="keyword">char</span> buf1[]=<span class="string">"ABCDEFG"</span>;</span><br><span class="line">	<span class="keyword">char</span> buf2[]=<span class="string">"1234567"</span>;</span><br><span class="line">	vec[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">	vec[<span class="number">0</span>].iov_len=<span class="number">3</span>;</span><br><span class="line">	vec[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">	vec[<span class="number">1</span>].iov_len=<span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> str_len=writev(<span class="number">1</span>,vec,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWrite bytes: %d \n"</span>,str_len);	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>readv函数</strong></p>
<ul>
<li>头文件：<code>&lt;sys/uio.h&gt;</code></li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd 表示数据接收对象的文件描述符（或套接字）</li>
<li>iov iov结构体数组的地址值</li>
<li>iovcnt 第二个参数的数组长度</li>
</ul>
</li>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">	<span class="keyword">char</span> buf1[BUF_SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> buf2[BUF_SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	vec[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">	vec[<span class="number">0</span>].iov_len=<span class="number">5</span>;</span><br><span class="line">	vec[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">	vec[<span class="number">1</span>].iov_len=<span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> str_len = readv(<span class="number">0</span>,vec,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Read bytes: %d \n"</span>,str_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"First message: %s \n"</span>, buf1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Second message: %s "</span>, buf2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第十四章-多播与广播"><a href="#第十四章-多播与广播" class="headerlink" title="第十四章 多播与广播"></a>第十四章 多播与广播</h1><h2 id="1-多播"><a href="#1-多播" class="headerlink" title="1. 多播"></a>1. 多播</h2><ul>
<li>多播方式的数据传输是基于UDP完成的。采用多播方式时，可以同时向多个主机传输数据。</li>
<li>多播组是D类IP地址,第1个字节的前四位固定为1110 , 范围：224.0.0.0~239.255.255.255</li>
<li>多播是借助路由器复制数据包完成的</li>
<li>TTL设置方法：通过设置套接字选项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> recv_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_live</span> = 64;</span></span><br><span class="line">…………</span><br><span class="line">send_sock = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">setopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(<span class="keyword">void</span>*)&amp;time_live,<span class="keyword">sizeof</span>(time_live));</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>
<ul>
<li>加入多播组的方法：通过设置套接字选项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> recv_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line">…………</span><br><span class="line">recv_sock = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">…………</span><br><span class="line">join_adr.imr_multiaddr.s_addr=<span class="string">"&lt;多播组地址信息&gt;"</span>;</span><br><span class="line">join_adr.imr_interface.s_addr=<span class="string">"&lt;加入多播组的主机地址信息&gt;"</span>;</span><br><span class="line">setsockopt(recv_sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(<span class="keyword">void</span>*) &amp;join_adr,<span class="keyword">sizeof</span>(join_adr));</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>


<h2 id="2-广播"><a href="#2-广播" class="headerlink" title="2. 广播"></a>2. 广播</h2><ul>
<li>广播也是基于UDP完成的</li>
<li>广播分为两种：直接广播和本地广播。</li>
<li>直接广播的IP地址中除了网络地址外，其余主机地址全部为1。可以采用直接广播的方式向特定区域内的所有字节传输数据。</li>
<li>本地广播的IP地址限定为255.255.255.255。</li>
<li>设置允许进行数据广播<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> send_sock;</span><br><span class="line"><span class="keyword">int</span> bast = <span class="number">1</span>;</span><br><span class="line">…………</span><br><span class="line">send_sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">…………</span><br><span class="line">setsockopt(send_sock,SOL_SOCKET,SO_BROADCAST,(<span class="keyword">void</span> *)&amp;bast,<span class="keyword">sizeof</span>(bast));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第二十四章-制作HTTP服务器端"><a href="#第二十四章-制作HTTP服务器端" class="headerlink" title="第二十四章 制作HTTP服务器端"></a>第二十四章 制作HTTP服务器端</h1><ul>
<li>HTTP，Hypertext Transfer Protocol, 超文本传输协议，基于TCP/IP实现的以超文本传输为目的的应用层协议。</li>
<li>HTTP协议是无状态的协议，服务端响应客户端后立即断开连接</li>
<li>状态码：表示客户端请求的执行结果<ul>
<li>200 OK：成功处理了请求</li>
<li>404 Not Found：请求的文件不存在</li>
<li>400 Bad Request：错误的请求</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/06/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keaper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keaper's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/06/tcpip%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93(1)/" itemprop="url">
                  TCP/IP网络编程复习总结(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-06 13:23:00" itemprop="dateCreated datePublished" datetime="2017-06-06T13:23:00+00:00">2017-06-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-05 11:18:57" itemprop="dateModified" datetime="2020-07-05T11:18:57+00:00">2020-07-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-理解网络编程和套接字"><a href="#第一章-理解网络编程和套接字" class="headerlink" title="第一章 理解网络编程和套接字"></a>第一章 理解网络编程和套接字</h1><h2 id="1-理解网络编程和套接字"><a href="#1-理解网络编程和套接字" class="headerlink" title="1. 理解网络编程和套接字"></a>1. 理解网络编程和套接字</h2><ul>
<li>网络编程就是编写程序使得两台计算机相互交换数据。</li>
<li>套接字是网络传输所用的软件设备。</li>
</ul>
<h2 id="2-基于linux的文件操作"><a href="#2-基于linux的文件操作" class="headerlink" title="2. 基于linux的文件操作"></a>2. 基于linux的文件操作</h2><ul>
<li>对于linux而言，socket操作和文件操作没有区别。socket也被认为是文件的一种，因此在网络数据传输过程中可以使用文件I/O的相关函数。而Windows是区分socket与文件的。</li>
<li>文件描述符：系统分配给文件或套接字的一个整数，用以标识文件或者套接字。    </li>
<li>标准输出输出以及标准错误文件描述符：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">文件描述符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准输入：stdin</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">标准输出：stdout</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">标准错误：stderr</td>
<td align="center">2</td>
</tr>
</tbody></table>
<h2 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3. 文件操作"></a>3. 文件操作</h2><p><strong>打开文件open()</strong></p>
<ul>
<li>头文件：<code>&lt;sys/types.h&gt;</code>,<code>&lt;sys/stat.h&gt;</code>, <code>&lt;fcntl.h&gt;</code><br><em>注：文件的打开模式定义在头文件<code>&lt;sys/stat.h&gt;</code>中，<code>&lt;sys/types.h&gt;</code>中定义了各种数据类型，open()函数定义在<code>&lt;fcntl.h&gt;</code>头文件中。</em></li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> str * path, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值：成功则返回文件描述符，出错返回-1 </li>
<li>参数：<ul>
<li>path: 打开或创建的文件的路径名 </li>
<li>flag：文件打开模式信息</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">打开模式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O_CREAT</td>
<td align="center">必要时创建文件</td>
</tr>
<tr>
<td align="center">O_TRUNC</td>
<td align="center">删除全部现有数据</td>
</tr>
<tr>
<td align="center">O_APPEND</td>
<td align="center">维持现有数据，白村到其后面</td>
</tr>
<tr>
<td align="center">O_RDONLY</td>
<td align="center">只读打开</td>
</tr>
<tr>
<td align="center">O_WRONLY</td>
<td align="center">只写打开</td>
</tr>
<tr>
<td align="center">O_RDWR</td>
<td align="center">读写打开</td>
</tr>
</tbody></table>
<p><strong>关闭文件close()</strong></p>
<ul>
<li>需要包含的头文件：<code>&lt;unistd.h&gt;</code></li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd:需要关闭文件的文件描述符</li>
</ul>
</li>
</ul>
<p><strong>读取文件中的数据read()</strong></p>
<ul>
<li>需要包含的头文件：<code>&lt;unistd.h&gt;</code></li>
<li>函数原型：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值：成功时返回实际读到的字节数；已读到文件尾返回0，出错的话返回-1。</li>
<li>参数：<ul>
<li>fd：要读取的文件的描述符<ul>
<li>buf：得到的数据在内存中的位置的首地址</li>
<li>nbytes：要接受数据的最大字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>向文件中写数据write()</strong></p>
<ul>
<li>需要包含的头文件：<code>&lt;unistd.h&gt;</code></li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>功能：向打开的文件写数据</li>
<li>返回值：写入成功返回实际写入的字节数，出错返回-1</li>
<li>参数：<ul>
<li>fd：要写入文件的文件描述符</li>
<li>buf：要写入文件的数据在内存中存放位置的首地址</li>
<li>nbytes：要传输数据的最大字节数</li>
</ul>
</li>
<li>样例代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buf[]=<span class="string">"Hello World!"</span>;</span><br><span class="line">	</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"data.txt"</span>,O_CREAT|O_WRONLY|O_TRUNC); 	<span class="comment">//打开文件</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File descriptor : %d \n"</span>,fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(fd,buf,<span class="keyword">sizeof</span>(buf));	<span class="comment">//写数据</span></span><br><span class="line">	<span class="built_in">close</span>(fd);					<span class="comment">//关闭文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">	</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"data.txt"</span>,O_RDONLY);		<span class="comment">//打开文件</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File descriptor: %d \n"</span> , fd);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));			<span class="comment">//读数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File data: %s\n"</span>,buf);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd);			<span class="comment">//关闭文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-套接字类型与协议设置"><a href="#第二章-套接字类型与协议设置" class="headerlink" title="第二章 套接字类型与协议设置"></a>第二章 套接字类型与协议设置</h1><h2 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1. 创建套接字socket()"></a>1. 创建套接字socket()</h2><ul>
<li>需要包含的头文件 &lt;sys/socket.h&gt;</li>
<li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值：成功：文件描述符；否则：-1。</li>
<li>参数：<ul>
<li>domain：套接字所使用的协议族</li>
<li>type：套接字数据传输类型</li>
<li>protocol：套接字所使用的协议</li>
</ul>
</li>
</ul>
<h2 id="2-参数domain-常用协议族"><a href="#2-参数domain-常用协议族" class="headerlink" title="2. 参数domain:常用协议族"></a>2. 参数domain:常用协议族</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">协议族</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PF_INET</td>
<td align="center">IPv4互联网协议族</td>
</tr>
<tr>
<td align="center">PF_INET6</td>
<td align="center">IPv46互联网协议族</td>
</tr>
<tr>
<td align="center">PF_LOCAL</td>
<td align="center">本地通信的UNIX协议族</td>
</tr>
</tbody></table>
<h2 id="3-参数type-套接字类型"><a href="#3-参数type-套接字类型" class="headerlink" title="3. 参数type:套接字类型"></a>3. 参数type:套接字类型</h2><ul>
<li><p>类型1：面向连接的套接字（SOCK_STREAM）<br><strong>可靠、按序传递的、基于字节的面向连接的套接字。</strong></p>
<ul>
<li>传输过程中数据不会消失：错误重传</li>
<li>按序传输数据：按发送顺序放入buffer</li>
<li>传输的数据不存在数据边界</li>
<li>面向连接的套接字只能与另外一个同样特性的套接字连接，一一对应</li>
</ul>
</li>
<li><p>类型2：面向消息的套接字（SOCK_DGRAM）<br><strong>不可靠的、不按序传递、以数据的高速传输为目的的套接字。</strong></p>
<ul>
<li>快速传输而非传输顺序</li>
<li>传输的数据可能丢失也可能损毁</li>
<li>传输的数据有边界</li>
<li>每次传输的数据大小有限</li>
</ul>
</li>
</ul>
<h2 id="4-参数protocol-协议类型"><a href="#4-参数protocol-协议类型" class="headerlink" title="4. 参数protocol:协议类型"></a>4. 参数protocol:协议类型</h2><ul>
<li><p>如果一个协议族中存在多种数据传输方式，该参数用以确定最终采用的协议。如果前两个参数已唯一确定，这个参数传0即可。</p>
</li>
<li><p>创建TCP套接字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_STREAM,IPPROTO_TCP);</span><br></pre></td></tr></table></figure></li>
<li><p>创建UDP套接字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_DGRAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET,SOCKET_DGRAM,IPPROTO_UDP);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第三章-地址族与数据序列"><a href="#第三章-地址族与数据序列" class="headerlink" title="第三章 地址族与数据序列"></a>第三章 地址族与数据序列</h1><h2 id="1-IP地址与端口号"><a href="#1-IP地址与端口号" class="headerlink" title="1. IP地址与端口号"></a>1. IP地址与端口号</h2><ul>
<li>IPv4的地址有4字节，32位。</li>
<li>端口号有16位构成，范围为0～65535。</li>
<li>端口号就是为了在同一个操作系统内区分不同套接字而设置的，无法将一个端口号分配给不同的套接字。</li>
</ul>
<h2 id="2-地址信息的表示"><a href="#2-地址信息的表示" class="headerlink" title="2. 地址信息的表示"></a>2. 地址信息的表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin_family;</span><br><span class="line">	<span class="keyword">uint16_t</span>        sin_port;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span>            sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-成员sin-family"><a href="#1-成员sin-family" class="headerlink" title="(1) 成员sin_family"></a>(1) 成员sin_family</h3><p>地址族，每种协议族适用的地址族均不同。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">地址族</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AF_INET</td>
<td align="center">IPv4网络协议使用的地址族</td>
</tr>
<tr>
<td align="center">AF_INET6</td>
<td align="center">IPv6网络协议使用的地址族</td>
</tr>
<tr>
<td align="center">AF_LOCAL</td>
<td align="center">本地通信中采用的UNIX协议的地址族</td>
</tr>
</tbody></table>
<h3 id="2-成员sin-port"><a href="#2-成员sin-port" class="headerlink" title="(2) 成员sin_port"></a>(2) 成员sin_port</h3><p>16位端口号，以网络字节序保存。</p>
<h3 id="3-成员sin-addr"><a href="#3-成员sin-addr" class="headerlink" title="(3) 成员sin_addr"></a>(3) 成员sin_addr</h3><p>保存32位地址信息，以网络字节序保存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-成员sin-zero"><a href="#4-成员sin-zero" class="headerlink" title="(4) 成员sin_zero"></a>(4) 成员sin_zero</h3><p>无特殊含义，是为了使sockaddr_in的大小与sockaddr结构体的大小一致而插入的，必须填充为0.</p>
<h2 id="3-sockaddr-in结构体的使用"><a href="#3-sockaddr-in结构体的使用" class="headerlink" title="3. sockaddr_in结构体的使用"></a>3. sockaddr_in结构体的使用</h2><p>bind函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure>
<p>第二个参数接期望得到一个sockaddr结构体变量地址值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span>     sin_family; </span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];				<span class="comment">/* Address data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以使用时要将sockaddr_in结构体变量的地址转换位sockaddr结构体变量的指针，然后再传递给bind函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">…………</span><br><span class="line"><span class="keyword">if</span>(bind(serv_sock, (struct sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>); </span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<h2 id="4-网络字节序与地址变换"><a href="#4-网络字节序与地址变换" class="headerlink" title="4. 网络字节序与地址变换"></a>4. 网络字节序与地址变换</h2><ul>
<li>字节序有大端小端之分。<ul>
<li>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。</li>
<li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。</li>
</ul>
</li>
<li>网络字节序统一为大端方式。所以传输之前应该进行字节序转换。</li>
<li>为了进行转换socket提供了转换的函数有下面四个:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;			\\头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> short)</span></span>; 	\\把<span class="keyword">unsigned</span> short类型从主机序转换到网络序</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> short)</span></span>; 	\\把<span class="keyword">unsigned</span> short类型从网络序转换到主机序</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>; 	\\把<span class="keyword">unsigned</span> <span class="keyword">long</span>类型从主机序转换到网络序</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;	\\把<span class="keyword">unsigned</span> <span class="keyword">long</span>类型从网络序转换到主机序</span><br></pre></td></tr></table></figure></li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> short host_port=<span class="number">0x1234</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> short net_port;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> host_addr=<span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> net_addr;</span><br><span class="line">	</span><br><span class="line">	net_port = htons(host_port);</span><br><span class="line">	net_addr = htons(host_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Host ordered port: %#x \n"</span>, host_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Network ordered port: %#x \n"</span>, net_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Host ordered address: %#lx \n"</span>, host_addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Network ordered address: %#lx \n"</span>, net_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Host ordered port: 0x1234 </span></span><br><span class="line"><span class="comment">Network ordered port: 0x3412 </span></span><br><span class="line"><span class="comment">Host ordered address: 0x12345678 </span></span><br><span class="line"><span class="comment">Network ordered address: 0x7856</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="5-网络地址的初始化与分配"><a href="#5-网络地址的初始化与分配" class="headerlink" title="5. 网络地址的初始化与分配"></a>5. 网络地址的初始化与分配</h2><h3 id="1-将字符串信息转换为网络字节序的整数型值"><a href="#1-将字符串信息转换为网络字节序的整数型值" class="headerlink" title="(1) 将字符串信息转换为网络字节序的整数型值"></a>(1) 将字符串信息转换为网络字节序的整数型值</h3><p><strong>inet_addr()函数</strong></p>
<ul>
<li>头文件：&lt;arpa/inet.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：点分十进制格式的IP地址字符串</li>
<li>返回值： 成功返回32位大端序整数型值，失败返回INADDR_NONE。</li>
</ul>
<p><strong>inet_aton()函数</strong></p>
<ul>
<li>头文件：&lt;arpa/inet.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>, struct in_addr *addr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>string—点分十进制格式的IP地址字符串</li>
<li>addr—保存转换结果的in_addr结构体变量的地址值。</li>
</ul>
</li>
<li>返回值：成功返回1，失败返回0</li>
</ul>
<p><strong>inet_ntoa()函数</strong> </p>
<ul>
<li>头文件：&lt;arpa/inet.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span> <span class="params">(struct in_addr adr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：需要转换的in_addr结构体</li>
<li>返回值：成功时返回转换的字符串地址值，失败返回-1</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *addr1=<span class="string">"1.2.3.4"</span>;</span><br><span class="line">	<span class="keyword">char</span> *addr2=<span class="string">"127.212.124.256"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> conv_addr = inet_addr(addr1);</span><br><span class="line">	<span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error occured! \n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n"</span>, conv_addr);</span><br><span class="line">	</span><br><span class="line">	conv_addr = inet_addr(addr2);</span><br><span class="line">	<span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error occureded \n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n\n"</span>, conv_addr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Network ordered integer addr: 0x4030201 </span></span><br><span class="line"><span class="comment">Error occureded</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * addr = <span class="string">"1.2.3.4"</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!inet_aton(addr,&amp;addr_inet.sin_addr))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Conversion error"</span>);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#x \n"</span>,addr_inet.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Network ordered integer addr: 0x4030201</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> * str_ptr;</span><br><span class="line">	addr.sin_addr.s_addr = htonl(<span class="number">0x1020304</span>);</span><br><span class="line">	str_ptr= inet_ntoa(addr.sin_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dotted-Decimal notation: %s \n"</span>,str_ptr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Dotted-Decimal notation: 1.2.3.4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-常见的套接字创建过程中网络地址信息初始化方法"><a href="#2-常见的套接字创建过程中网络地址信息初始化方法" class="headerlink" title="(2) 常见的套接字创建过程中网络地址信息初始化方法"></a>(2) 常见的套接字创建过程中网络地址信息初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in addr;</span><br><span class="line">char * serv_ip &#x3D;&quot;211.217.168.13&quot;;</span><br><span class="line">char * serv_port &#x3D; &quot;9190&quot;;</span><br><span class="line">memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">addr.sin_family&#x3D;AF_INET;</span><br><span class="line">addr.sin_addr.s_addr&#x3D;htonl(serv_ip);</span><br><span class="line">addr.sin_port&#x3D;htons(atoi(serv_port));</span><br></pre></td></tr></table></figure>
<p>可以利用INADDR_ANY常量分配服务端IP地址，自动获取本机IP。</p>
<h3 id="3-向套接字分配网络地址-bind-函数"><a href="#3-向套接字分配网络地址-bind-函数" class="headerlink" title="(3) 向套接字分配网络地址 bind()函数"></a>(3) 向套接字分配网络地址 bind()函数</h3><ul>
<li>功能：<br>  bind函数将socket与网络地址信息绑定。</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sockfd—要分配地址信息的套接字文件描述符</li>
<li>myaddr—存有地址信息的sockaddr结构体变量的地址值。</li>
<li>addrlen—第二个结构体变量的长度</li>
</ul>
</li>
<li>返回值：<br>  成功返回0，失败返回-1</li>
</ul>
<h1 id="第四、五章-基于TCP的服务端-客户端"><a href="#第四、五章-基于TCP的服务端-客户端" class="headerlink" title="第四、五章 基于TCP的服务端/客户端"></a>第四、五章 基于TCP的服务端/客户端</h1><h2 id="1-TCP服务器端的默认函数调用顺序"><a href="#1-TCP服务器端的默认函数调用顺序" class="headerlink" title="1. TCP服务器端的默认函数调用顺序"></a>1. TCP服务器端的默认函数调用顺序</h2><ul>
<li>socket() 创建套接字</li>
<li>bind() 分配给套接字地址</li>
<li>listen() 等待连接请求状态</li>
<li>accept() 允许连接，接收新连接</li>
<li>read()/write() 数据交换</li>
<li>close() 关闭套接字，断开连接</li>
</ul>
<h2 id="2-进入等待连接请求状态-listen-函数"><a href="#2-进入等待连接请求状态-listen-函数" class="headerlink" title="2. 进入等待连接请求状态 listen()函数"></a>2. 进入等待连接请求状态 listen()函数</h2><ul>
<li>功能：<br>  进入等待连接请求状态</li>
<li>原型：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(int sock, int backlog);</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—希望进入等待连接请求状态的套接字文件描述符，该套接字将变为服务端套接字即监听套接字。</li>
<li>backlog—连接请求等待队列的长度。</li>
</ul>
</li>
<li>返回值：<br>  成功返回0，失败返回-1</li>
</ul>
<h2 id="3-受理客户端连接请求-connect-函数"><a href="#3-受理客户端连接请求-connect-函数" class="headerlink" title="3. 受理客户端连接请求 connect()函数"></a>3. 受理客户端连接请求 connect()函数</h2><ul>
<li>功能：接受客户端连接请求</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sock, struct sockaddr * addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—服务端套接字文件描述符</li>
<li>addr—保存发起连接请求的客户端地址信息的变量地址值，函数调用完成后，该地址保存的是客户端地址信息</li>
<li>addrlen—保存第二个参数sockaddr结构体的长度，函数调用完成后，该地址保存的客户端地址信息的长度</li>
</ul>
</li>
<li>返回值：成功时返回创建的套接字文件描述符，用以数据交换，失败时返回-1</li>
</ul>
<h2 id="4-TCP客户端的默认函数调用顺序"><a href="#4-TCP客户端的默认函数调用顺序" class="headerlink" title="4. TCP客户端的默认函数调用顺序"></a>4. TCP客户端的默认函数调用顺序</h2><ul>
<li>socket() 创建套接字</li>
<li>connect() 请求连接</li>
<li>read()/write() 数据交换</li>
<li>close() 关闭套接字，断开连接</li>
</ul>
<h2 id="5-客户端发起连接请求connect-函数"><a href="#5-客户端发起连接请求connect-函数" class="headerlink" title="5. 客户端发起连接请求connect()函数"></a>5. 客户端发起连接请求connect()函数</h2><ul>
<li><p>功能：<br>  请求连接到服务器</p>
</li>
<li><p>原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sock, struct sockaddr * servaddr, socklen_t addrlen);</span><br></pre></td></tr></table></figure></li>
<li><p>参数：</p>
<ul>
<li>sock—客户端套接字文件描述符</li>
<li>servaddr—存有目标服务器端地址信息的变量地址值</li>
<li>addrlen—第二个参数sockaddr结构体的长度</li>
</ul>
</li>
<li><p>客户端调用connect函数后，发生一下情况之一才会返回：</p>
</li>
</ul>
<ol>
<li>服务端接受连接请求。</li>
<li>发生断网等异常情况而中断连接请求。</li>
</ol>
<ul>
<li>注：客户端的IP地址和端口号在调用connect函数是自动分配。</li>
</ul>
<h2 id="6-第一个基于TCP的服务端-客户端—HelloWorld服务器"><a href="#6-第一个基于TCP的服务端-客户端—HelloWorld服务器" class="headerlink" title="6. 第一个基于TCP的服务端/客户端—HelloWorld服务器"></a>6. 第一个基于TCP的服务端/客户端—HelloWorld服务器</h2><p>服务端代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义套接字</span></span><br><span class="line">	<span class="keyword">int</span> serv_sock; <span class="comment">//用于监听的套接字</span></span><br><span class="line">	<span class="keyword">int</span> clnt_sock; <span class="comment">//用于数据传输的套接字</span></span><br><span class="line">	<span class="comment">//定义地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">//服务端地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span> <span class="comment">//请求连接的客户端地址信息</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clnt_addr_size;	<span class="comment">//客户端地址信息长度</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> message[]=<span class="string">"Hello World!"</span>;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	serv_sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//地址信息初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family = AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">//绑定地址信息</span></span><br><span class="line">		<span class="comment">//需要将sockaddr_in结构体变量地址强制转换为sockaddr结构体类型指针</span></span><br><span class="line">	<span class="keyword">if</span>(bind(serv_sock,(struct sockaddr*) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>) </span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"liste() error"</span>);</span><br><span class="line">	<span class="comment">//接受客户端连接请求</span></span><br><span class="line">		<span class="comment">//需要将sockaddr_in结构体变量地址强制转换为sockaddr结构体类型指针</span></span><br><span class="line">	clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">	clnt_sock = accept(serv_sock,(struct sockaddr*) &amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">	<span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">	<span class="comment">//向客户端发送一句“Hello World!”</span></span><br><span class="line">	<span class="built_in">write</span>(clnt_sock,message,<span class="keyword">sizeof</span>(message));</span><br><span class="line">	<span class="comment">//关闭数据交换套接字</span></span><br><span class="line">	<span class="built_in">close</span>(clnt_sock);</span><br><span class="line">	<span class="comment">//关闭监听套接字</span></span><br><span class="line">	<span class="built_in">close</span>(serv_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义套接字</span></span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="comment">//定义服务端地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	<span class="comment">//存放接受的消息</span></span><br><span class="line">	<span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//服务端地址信息初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family = AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">	<span class="comment">//请求连接服务端</span></span><br><span class="line">		<span class="comment">//需要将sockaddr_in结构体变量地址强制转换为sockaddr结构体类型指针</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">connect</span>(sock,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"conect() error!"</span>);</span><br><span class="line">	<span class="comment">//接受服务端发送的信息</span></span><br><span class="line">	<span class="keyword">int</span> str_len = <span class="built_in">read</span>(sock,message,<span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(str_len == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"read() error!"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>,message);</span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-基于TCP的服务端客户端函数调用关系"><a href="#7-基于TCP的服务端客户端函数调用关系" class="headerlink" title="7. 基于TCP的服务端客户端函数调用关系"></a>7. 基于TCP的服务端客户端函数调用关系</h2><p>服务端创建套接字后连续调用bind(),listen()函数进入等待状态，客户端创建套接字后通过connect()发起连接请求。服务端调用accept(),接受一个连接请求，接受之后客户端connect函数返回，双方进入数据交换阶段，如果队列中没有连接请求，则进入阻塞状态。数据交换阶段，通过调用read()/write()函数交换数据。结束之后调用close()关闭套接字，断开连接。</p>
<h2 id="8-迭代服务端-客户端"><a href="#8-迭代服务端-客户端" class="headerlink" title="8. 迭代服务端/客户端"></a>8. 迭代服务端/客户端</h2><h3 id="1-迭代服务端函数调用顺序"><a href="#1-迭代服务端函数调用顺序" class="headerlink" title="(1) 迭代服务端函数调用顺序"></a>(1) 迭代服务端函数调用顺序</h3><p>重复调用accept函数以实现可以向多个客户端提供服务但是统一时刻还是只能为一个客户端提供服务，与一个客户端通信是其他客户端只能阻塞。</p>
<h3 id="2-迭代的回声服务端-客户端"><a href="#2-迭代的回声服务端-客户端" class="headerlink" title="(2) 迭代的回声服务端/客户端"></a>(2) 迭代的回声服务端/客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">…………</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		clnt_sock=accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">		<span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">			error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Connected client %d \n"</span>, i+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>((str_len=<span class="built_in">read</span>(clnt_sock, message, BUF_SIZE))!=<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">write</span>(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">close</span>(clnt_sock);</span><br><span class="line">	&#125;</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>
<h2 id="9-解决TCP不存在数据边界的问题"><a href="#9-解决TCP不存在数据边界的问题" class="headerlink" title="9. 解决TCP不存在数据边界的问题"></a>9. 解决TCP不存在数据边界的问题</h2><p>自定义应用层协议</p>
<h2 id="10-TCP原理"><a href="#10-TCP原理" class="headerlink" title="10. TCP原理"></a>10. TCP原理</h2><h3 id="1-I-O缓冲"><a href="#1-I-O缓冲" class="headerlink" title="(1) I/O缓冲"></a>(1) I/O缓冲</h3><ul>
<li>I/O缓冲在每个TCP套接字中单独存在</li>
<li>I/O缓冲在创建套接字时自动生成</li>
<li>即使关闭套接字也会继续传递输出缓冲中遗留的数据</li>
<li>关闭套接字将丢失输入缓冲中的数据</li>
</ul>
<h3 id="2-套接字的连接"><a href="#2-套接字的连接" class="headerlink" title="(2) 套接字的连接"></a>(2) 套接字的连接</h3><p>三次握手</p>
<p><strong>套接字是以全双工的方式工作的，也就是说，它可以双向传递数据。</strong></p>
<h3 id="3-数据交换"><a href="#3-数据交换" class="headerlink" title="(3) 数据交换"></a>(3) 数据交换</h3><h3 id="4-断开套接字连接"><a href="#4-断开套接字连接" class="headerlink" title="(4) 断开套接字连接"></a>(4) 断开套接字连接</h3><p>四次挥手</p>
<h1 id="第六章-基于UDP的服务端-客户端"><a href="#第六章-基于UDP的服务端-客户端" class="headerlink" title="第六章 基于UDP的服务端/客户端"></a>第六章 基于UDP的服务端/客户端</h1><h2 id="1-UDP协议"><a href="#1-UDP协议" class="headerlink" title="1. UDP协议"></a>1. UDP协议</h2><ul>
<li>TCP比UDP慢的原因<ul>
<li>收发数据前后需要进行连接和清除过程</li>
<li>收发数据过程中需要添加流控制, 以保证数据可靠性</li>
</ul>
</li>
<li>UDP的高效使用<ul>
<li>如果数据完整性要求高, 使用TCP, 例如传送压缩的数据</li>
<li>如果可以容忍少量数据丢失, 使用UDP, 例如视频音频</li>
</ul>
</li>
</ul>
<h2 id="2-实现基于UDP的服务端-客户端"><a href="#2-实现基于UDP的服务端-客户端" class="headerlink" title="2. 实现基于UDP的服务端/客户端"></a>2. 实现基于UDP的服务端/客户端</h2><ul>
<li>UDP服务端和客户端没有连接<ul>
<li>不是面向连接的, 不需要连接过程</li>
<li>只需创建套接字, 然后进行数据交换, 不需要listen和accept</li>
</ul>
</li>
<li>UDP服务端和客户端均只需一个套接字<ul>
<li>TCP: 用于连接的套接字,以及数据交换的套接字(将保持连接)</li>
<li>UDP: 只需一个套接字(每次交换数据是需要添加目标地址信息)</li>
</ul>
</li>
</ul>
<h2 id="3-基于UDP的数据I-O函数"><a href="#3-基于UDP的数据I-O函数" class="headerlink" title="3. 基于UDP的数据I/O函数"></a>3. 基于UDP的数据I/O函数</h2><p><strong>sendto函数</strong></p>
<ul>
<li>功能：<br>  发送数据到对端</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> flags, struct sockaddr *to,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—用于传输数据的套接字文件描述符</li>
<li>buff—存有待传送数据的缓冲地址值</li>
<li>nbytes—待传输数据长度</li>
<li>flags—可选参数，若没有传递0</li>
<li>to—存有目标地址信息的sockaddr结构体变量的地址值</li>
<li>addrlen—参数to的地址值结构体变量长度</li>
</ul>
</li>
</ul>
<p><strong>recvfrom函数</strong></p>
<ul>
<li>功能：<br>  接收对端数据</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> flags, struct sockaddr * from,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock—用于接受数据的套接字文件描述符</li>
<li>buff—用于保存接收数据的缓冲地址值</li>
<li>nbytes—可接收的最大字节数</li>
<li>flags—可选参数</li>
<li>from—存有发送端地址信息的sockaddr结构体变量的地址值</li>
<li>addrlen—参数法from的地址值结构体变量长度</li>
</ul>
</li>
</ul>
<p><strong>基于UDP的回声服务端/客户端:</strong></p>
<p>服务端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> serv_sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	serv_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"UDP socket() error"</span>);</span><br><span class="line">	<span class="comment">//初始化地址信息</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">//绑定地址信息</span></span><br><span class="line">	<span class="keyword">if</span>(bind(serv_sock,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">	<span class="comment">//读写数据</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">		<span class="keyword">int</span> str_len = recvfrom(serv_sock,message,<span class="keyword">sizeof</span>(message),</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">		sendto(serv_sock,message,str_len,</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;clnt_addr,clnt_addr_size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(serv_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">	fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> addr_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	sock = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">	<span class="comment">//初始化服务器地址信息</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">	<span class="comment">//数据交换</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"Insert message(q to quit): "</span>,<span class="built_in">stdout</span>);</span><br><span class="line">		fgets(message, <span class="keyword">sizeof</span>(message),<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		sendto(sock,message,<span class="built_in">strlen</span>(message),</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">		addr_size = <span class="keyword">sizeof</span>(serv_addr);</span><br><span class="line">		<span class="keyword">int</span> str_len = recvfrom(sock,message,BUF_SIZE,</span><br><span class="line">				<span class="number">0</span>,(struct sockaddr *) &amp;serv_addr,&amp;addr_size);</span><br><span class="line">		message[str_len] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Message from server:  %s"</span>,message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：UDP客户端套接字的地址分配：调用sendto函数时自动分配IP和端口号。</strong></p>
<h2 id="4-UDP的数据传输特性"><a href="#4-UDP的数据传输特性" class="headerlink" title="4. UDP的数据传输特性"></a>4. UDP的数据传输特性</h2><p>UDP具有数据边界，传输过程中调用I/O函数的次数必须完全一致。<br>因为存在数据边界, 一个数据报即可成为一个完整数据,所以UDP套接字传输的数据包又称为数据报。</p>
<h2 id="5-未连接UDP套接字与已连接UDP套接字"><a href="#5-未连接UDP套接字与已连接UDP套接字" class="headerlink" title="5. 未连接UDP套接字与已连接UDP套接字"></a>5. 未连接UDP套接字与已连接UDP套接字</h2><ul>
<li>UDP套接字默认都是未连接套接字,每次sendto都要经历三个阶段：<ul>
<li>向UDP套接字注册目标IP和端口号</li>
<li>交换数据</li>
<li>删除UDP套接字中注册的目标地址信息</li>
</ul>
</li>
<li>如果连续想同一个IP地址和端口发送数据，未连接套接字浪费</li>
<li>已连接UDP套接字<br>创建已连接UDP套接字只需要针对套接字调用connect函数即可。之后可以使用sendto，recvfrom函数进行数据交换，还可以使用write，read函数交换数据。</li>
<li>示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sock,(struct sockaddr *) &amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">"Insert message(q to quit): "</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	fgets(message, <span class="keyword">sizeof</span>(message),<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">"q\n"</span>) || !<span class="built_in">strcmp</span>(message,<span class="string">"Q\n"</span>))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	sendto(sock,message,strlen(message),</span></span><br><span class="line"><span class="comment">			0,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr));</span></span><br><span class="line"><span class="comment">	addr_size = sizeof(serv_addr);</span></span><br><span class="line"><span class="comment">	int str_len = recvfrom(sock,message,BUF_SIZE,</span></span><br><span class="line"><span class="comment">			0,(struct sockaddr *) &amp;serv_addr,&amp;addr_size);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(sock,message,<span class="built_in">strlen</span>(message));</span><br><span class="line">	<span class="keyword">int</span> str_len=<span class="built_in">read</span>(sock,message,BUF_SIZE);</span><br><span class="line"></span><br><span class="line">	message[str_len] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message from server:  %s"</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第七章-优雅地断开套接字连接"><a href="#第七章-优雅地断开套接字连接" class="headerlink" title="第七章 优雅地断开套接字连接"></a>第七章 优雅地断开套接字连接</h1><h2 id="1-基于TCP的半关闭"><a href="#1-基于TCP的半关闭" class="headerlink" title="1. 基于TCP的半关闭"></a>1. 基于TCP的半关闭</h2>半关闭：只关闭一部分数据交换中使用的流，即只关闭一个方向的数据交换。<h2 id="2-针对半关闭的shutdown-函数"><a href="#2-针对半关闭的shutdown-函数" class="headerlink" title="2. 针对半关闭的shutdown()函数"></a>2. 针对半关闭的shutdown()函数</h2></li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock — 要断开的套接字文件描述符</li>
<li>howto — 断开方式</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">howto值</th>
<th align="center">断开方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHUT_RD</td>
<td align="center">断开输入流</td>
</tr>
<tr>
<td align="center">SHUT_WR</td>
<td align="center">断开输出流</td>
</tr>
<tr>
<td align="center">SHUT_RDWR</td>
<td align="center">同时断开I/O流</td>
</tr>
</tbody></table>
<ul>
<li>返回值：成功返回0,失败返回-1</li>
</ul>
<h1 id="第八章-域名及网络地址"><a href="#第八章-域名及网络地址" class="headerlink" title="第八章 域名及网络地址"></a>第八章 域名及网络地址</h1><h2 id="1-域名系统"><a href="#1-域名系统" class="headerlink" title="1. 域名系统"></a>1. 域名系统</h2><ul>
<li>DNS是对IP地址和域名进行转换的系统，其核心是DNS服务器。</li>
</ul>
<h2 id="2-利用域名获取IP地址"><a href="#2-利用域名获取IP地址" class="headerlink" title="2. 利用域名获取IP地址"></a>2. 利用域名获取IP地址</h2><p><strong>gethostbyname函数</strong></p>
<ul>
<li>包含头文件：&lt;netdb.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<br>  hotname — 域名字符串</li>
<li>返回值：<br>  成功时返回hostent结构体地址，失败时返回NULL指针</li>
</ul>
<p><strong>hostent结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *h_name;			<span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="keyword">char</span> **h_aliases;		<span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="keyword">int</span> h_addrtype;		<span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="keyword">int</span> h_length;			<span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="keyword">char</span> **h_addr_list;		<span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>h_name：官方域名</li>
<li>h_aliases：多个域名列表</li>
<li>h_addrtype：地址类型，若是IPv4，则词变量为AF_INET</li>
<li>h_length：IP地址长度。若是IPv4，为4,若是IPv6，为16</li>
<li>h_addr_list：以整数形式保存的域名对应的IP地址</li>
</ul>
<h2 id="3-利用IP地址获取域名"><a href="#3-利用IP地址获取域名" class="headerlink" title="3. 利用IP地址获取域名"></a>3. 利用IP地址获取域名</h2><p><strong>gethostbyaddr函数</strong></p>
<ul>
<li>包含头文件：&lt;netdb.h&gt;</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>addr — 含有IP地址信息的in_addr结构体指针。为了同时传递IPv4地址之外的信息，该变量的类型声明为char型指针。</li>
<li>len — 第一个参数地址信息的字节数，IPv4为4,IPv6为16</li>
<li>family — 地址族信息，IPv4时为AF_INET，IPv6时为AF_INET6</li>
</ul>
</li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> * <span class="title">host</span>;</span></span><br><span class="line">	host = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Official name: %s \n"</span>, host-&gt;h_name);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_aliases[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Aliases %d: %s \n"</span>, i+<span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Address type: %s \n"</span>,</span><br><span class="line">			(host-&gt;h_addrtype==AF_INET)?<span class="string">"AF_INET"</span>:<span class="string">"AF_INET6"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_addr_list[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"IP addr %d : %s \n"</span>,i+<span class="number">1</span>,</span><br><span class="line">				inet_ntoa(*(struct in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">$./gethostbyname baidu.com</span></span><br><span class="line"><span class="comment">Official name: baidu.com </span></span><br><span class="line"><span class="comment">Address type: AF_INET </span></span><br><span class="line"><span class="comment">IP addr 1 : 180.149.132.47 </span></span><br><span class="line"><span class="comment">IP addr 2 : 220.181.57.217 </span></span><br><span class="line"><span class="comment">IP addr 3 : 111.13.101.208 </span></span><br><span class="line"><span class="comment">IP addr 4 : 123.125.114.144 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> * <span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">	host = gethostbyaddr((<span class="keyword">char</span>*)&amp;addr.sin_addr,<span class="number">4</span>,AF_INET);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Official name: %s \n"</span>, host-&gt;h_name);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_aliases[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Aliases %d: %s \n"</span>, i+<span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Address type: %s \n"</span>,</span><br><span class="line">			(host-&gt;h_addrtype==AF_INET)?<span class="string">"AF_INET"</span>:<span class="string">"AF_INET6"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_addr_list[i];i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"IP addr %d : %s \n"</span>,i+<span class="number">1</span>,</span><br><span class="line">				inet_ntoa(*(struct in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">$ ./gethostbyaddr 127.0.0.1</span></span><br><span class="line"><span class="comment">Official name: localhost </span></span><br><span class="line"><span class="comment">Address type: AF_INET </span></span><br><span class="line"><span class="comment">IP addr 1 : 127.0.0.1 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="第九章-套接字的多种选项"><a href="#第九章-套接字的多种选项" class="headerlink" title="第九章 套接字的多种选项"></a>第九章 套接字的多种选项</h1><h2 id="1-套接字选项"><a href="#1-套接字选项" class="headerlink" title="1. 套接字选项"></a>1. 套接字选项</h2><p><strong>getsockopt()</strong></p>
<ul>
<li>头文件 <code>&lt;sys/socket.h&gt;</code></li>
<li>功能：获取套接字选项</li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock — 用于查看套接字选项的套接字文件描述符</li>
<li>level — 要查看选项的协议层</li>
<li>optname — 要查看的选项名</li>
<li>optval — 保存结果的缓冲地址值</li>
<li>optlen — 保存通过第四个参数返回的可选项信息的字节数</li>
</ul>
</li>
<li>返回值<br>  成功返回0,失败返回-1</li>
</ul>
<p><strong>setsockopt()</strong></p>
<ul>
<li>头文件 <code>&lt;sys/socket.h&gt;</code></li>
<li>原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>sock — 要设置可选项的套接字文件描述符</li>
<li>level — 要设置的选项的协议层</li>
<li>optname — 要设置的选项名</li>
<li>optval — 存有要设置的选项信息的缓冲地址值</li>
<li>optlen — 向参数optval传递的选项信息的字节数</li>
</ul>
</li>
<li>返回值：<br>  成功返回0,失败返回-1</li>
</ul>
<h2 id="2-I-O缓冲大小选项-SO-SNDBUF-amp-SO-RECVBUF"><a href="#2-I-O缓冲大小选项-SO-SNDBUF-amp-SO-RECVBUF" class="headerlink" title="2. I/O缓冲大小选项 SO_SNDBUF &amp; SO_RECVBUF"></a>2. I/O缓冲大小选项 SO_SNDBUF &amp; SO_RECVBUF</h2><ul>
<li>SO_RECVBUF是输入缓冲大小可选项</li>
<li>SO_SNDBUF是输出缓冲大小可选项</li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="keyword">int</span> snd_buf,rcv_buf,state;</span><br><span class="line">	<span class="keyword">socklen_t</span> len;</span><br><span class="line">	</span><br><span class="line">	sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_SNDBUF,(<span class="keyword">void</span> *)&amp;snd_buf,&amp;len);</span><br><span class="line">	</span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_RCVBUF,(<span class="keyword">void</span> *)&amp;rcv_buf,&amp;len);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input buffer size: %d \n"</span>, rcv_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Outupt buffer size: %d \n"</span>, snd_buf);</span><br><span class="line">	</span><br><span class="line">	snd_buf /= <span class="number">4</span>;</span><br><span class="line">	rcv_buf /= <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line">	state = setsockopt(sock,SOL_SOCKET,SO_SNDBUF,(<span class="keyword">void</span> *)&amp;snd_buf,<span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">	state = setsockopt(sock,SOL_SOCKET,SO_RCVBUF,(<span class="keyword">void</span> *)&amp;rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_SNDBUF,(<span class="keyword">void</span> *)&amp;snd_buf,&amp;len);</span><br><span class="line">	</span><br><span class="line">	len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">	state = getsockopt(sock,SOL_SOCKET,SO_RCVBUF,(<span class="keyword">void</span> *)&amp;rcv_buf,&amp;len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input buffer size: %d \n"</span>, rcv_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Outupt buffer size: %d \n"</span>, snd_buf);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Input buffer size: 87380 </span></span><br><span class="line"><span class="comment">Outupt buffer size: 16384 </span></span><br><span class="line"><span class="comment">Input buffer size: 43690 </span></span><br><span class="line"><span class="comment">Outupt buffer size: 8192 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="3-地址再分配选项-SO-REUSEADDR-和Time-wait状态"><a href="#3-地址再分配选项-SO-REUSEADDR-和Time-wait状态" class="headerlink" title="3. 地址再分配选项 SO_REUSEADDR 和Time-wait状态"></a>3. 地址再分配选项 SO_REUSEADDR 和Time-wait状态</h2><p><strong>Time-wait状态</strong></p>
<ul>
<li>Time-wait状态出现在主动断开连接的一方，即先调用close()的一方</li>
<li>Time-wait状态的设置是为了确保最后一条ACK消息的准确到达</li>
<li>Time-wait并非只有优点</li>
</ul>
<p><strong>SO_REUSEADDR选项</strong></p>
<p>SO_REUSEADDR默认设置为0,意味着无法分配Time-wait状态下的套接字端口号。将该选项设置为1,则可将Time-wait状态下的套接字端口号重新分配给新的套接字。</p>
<h2 id="4-Nagle算法选项-TCP-NODELAY"><a href="#4-Nagle算法选项-TCP-NODELAY" class="headerlink" title="4. Nagle算法选项 TCP_NODELAY"></a>4. Nagle算法选项 TCP_NODELAY</h2><p><strong>Nagle算法</strong></p>
<ul>
<li>TCP默认使用Nagle算法交换数据，因此最大限度地进行缓冲，直到收到ACK。也就是只有收到前一数据的ACK消息时，才发送下一数据。</li>
<li>根据传输数据的特性，在网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。典型的是“传输大文件数据”。</li>
</ul>
<p><strong>禁用Nagle算法</strong></p>
<ul>
<li>如果有必要可以禁用Nagle算法</li>
<li>将TCP_NODELAY改为1即可禁用Nagle算法。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot; aria-label&#x3D;&quot;上一页&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Keaper" />
            
              <p class="site-author-name" itemprop="name">Keaper</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">58</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/J-keaper" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keaper</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
